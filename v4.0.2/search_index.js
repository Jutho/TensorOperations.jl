var documenterSearchIndex = {"docs":
[{"location":"man/interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"The @tensor macro rewrites tensor operations in terms of basic building blocks, such that any tensor type that implements the following interface can be supported. In these methods, C will indicate an output tensor which is changed in-place, while A and B denote input tensors that are left unaltered. pC, pA and pB denote an Index2Tuple, a tuple of two tuples that represents a permutation and partition of the original tensor indices. Finally, conjA and conjB are symbols that are used to indicate if the input tensor should be conjugated (:C) or used as-is (:N).","category":"page"},{"location":"man/interface/#Operations","page":"Interface","title":"Operations","text":"","category":"section"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"The three primitive tensor operations have already been described in the previous section, and correspond to","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"tensoradd!,\ntensortrace!,\ntensorcontract!.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"All other functions described in the previous section are implemented in terms of those. Hence, those are the only methods that need to be overloaded to support e.g. a new tensor type of to implement a new backend. There is one more necessary tensor operation, which is to convert back from a rank zero tensor to a scalar quantity.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"tensorscalar","category":"page"},{"location":"man/interface/#TensorOperations.tensorscalar","page":"Interface","title":"TensorOperations.tensorscalar","text":"tensorscalar(C)\n\nReturn the single element of a tensor-like object with zero indices or dimensions as a value of the underlying scalar type.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#Allocations","page":"Interface","title":"Allocations","text":"","category":"section"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"For some networks, it will be necessary to allocate output and/or intermediate tensors. This process is split into the following hierarchy of functions, where custom tensor types can opt in at different levels.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"By default, the process is split into three steps.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"First, the scalar type TC of the resulting tensor is determined. This is done by leveraging VectorInterface.jl's scalartype, and promoting the results along with the types of any scalars that are present.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"TensorOperations.promote_add\nTensorOperations.promote_contract","category":"page"},{"location":"man/interface/#TensorOperations.promote_add","page":"Interface","title":"TensorOperations.promote_add","text":"promote_add(args...)\n\nPromote the scalar types of a tensor addition to a common type.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.promote_contract","page":"Interface","title":"TensorOperations.promote_contract","text":"promote_contract(args...)\n\nPromote the scalar types of a tensor contraction to a common type.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"Then, the type and structure of the resulting tensor is determined. The former represents all the information that is contained within the type, while the latter adds the required runtime information (e.g. array sizes, ...).","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"TensorOperations.tensoradd_type\nTensorOperations.tensoradd_structure\nTensorOperations.tensorcontract_type\nTensorOperations.tensorcontract_structure","category":"page"},{"location":"man/interface/#TensorOperations.tensoradd_type","page":"Interface","title":"TensorOperations.tensoradd_type","text":"tensoradd_type(TC, pC, A, conjA)\n\nObtain typeof(C), where C is the result of tensoradd!(C, pC, A, conjA) with scalar type TC.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.tensoradd_structure","page":"Interface","title":"TensorOperations.tensoradd_structure","text":"tensoradd_structure(pC, A, conjA)\n\nObtain the structure information of C, where C would be the output of tensoradd!(C, pC, A, conjA).\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.tensorcontract_type","page":"Interface","title":"TensorOperations.tensorcontract_type","text":"tensorcontract_type(TC, pC, A, pA, conjA, B, pB, conjB)\n\nObtain typeof(C), where C is the result of tensorcontract!(C, pC, A, pA, conjA, B, pB, conjB) with scalar type TC.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.tensorcontract_structure","page":"Interface","title":"TensorOperations.tensorcontract_structure","text":"tensorcontract_structure(pC, A, pA, conjA, B, pB, conjB)\n\nObtain the structure information of C, where C would be the output of tensorcontract!(C, pC, A, pA, conjA, B, pB, conjB).\n\n\n\n\n\n","category":"function"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"Finally, the tensor is allocated, where a flag indicates if this is a temporary object, or one that will persist outside of the scope of the macro. If the resulting tensor is a temporary object and its memory will not be freed by Julia's garbage collector, it can be explicitly freed by implementing tensorfree!, which by default does nothing.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"tensoralloc\ntensorfree!","category":"page"},{"location":"man/interface/#TensorOperations.tensoralloc","page":"Interface","title":"TensorOperations.tensoralloc","text":"tensoralloc(ttype, structure, istemp=false, [backend::Backend])\n\nAllocate memory for a tensor of type ttype and structure structure. The optional third argument can be used to indicate that the result is used as a temporary tensor, for which in some cases and with some backends (the optional fourth argument) a different allocation strategy might be used.\n\nSee also tensoralloc_add, tensoralloc_contract and tensorfree!.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.tensorfree!","page":"Interface","title":"TensorOperations.tensorfree!","text":"tensorfree!(C, [backend::Backend])\n\nProvide a hint that the allocated memory of C can be released.\n\nSee also tensoralloc.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"The @tensor macro will however only insert the calls to the following functions, which have a default implementation in terms of the functions above.","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"TensorOperations.tensoralloc_add\nTensorOperations.tensoralloc_contract","category":"page"},{"location":"man/interface/#TensorOperations.tensoralloc_add","page":"Interface","title":"TensorOperations.tensoralloc_add","text":"tensoralloc_add(TC, pC, A, conjA, istemp=false, backend::Backend...)\n\nAllocate a tensor C of scalar type TC that would be the result of\n\n`tensoradd!(C, pC, A, conjA)`\n\nThe istemp argument is used to indicate that a tensor wlil not be used after the @tensor block, and thus will be followed by an explicit call to tensorfree!. The backend can be used to implement different allocation strategies.\n\nSee also tensoralloc and tensorfree!.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.tensoralloc_contract","page":"Interface","title":"TensorOperations.tensoralloc_contract","text":"tensoralloc_contract(TC, pC, A, pA, conjA, B, pB, conjB, istemp=false, backend::Backend...)\n\nAllocate a tensor C of scalar type TC that would be the result of\n\n`tensorcontract!(C, pC, A, pA, conjA, B, pB, conjB)`\n\nThe istemp argument is used to indicate that a tensor wlil not be used after the @tensor block, and thus will be followed by an explicit call to tensorfree!. The backend can be used to implement different allocation strategies.\n\nSee also tensoralloc and tensorfree!.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#Utility","page":"Interface","title":"Utility","text":"","category":"section"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"Some of the optional keywords for @tensor can be accessed only after implementing the following utility functions:","category":"page"},{"location":"man/interface/","page":"Interface","title":"Interface","text":"tensorcost\ncheckcontractible","category":"page"},{"location":"man/interface/#TensorOperations.tensorcost","page":"Interface","title":"TensorOperations.tensorcost","text":"tensorcost(A, i)\n\nCompute the contraction cost associated with the ith index of a tensor, such that the total cost of a pairwise contraction is found as the product of the costs of all contracted indices and all uncontracted indices.\n\n\n\n\n\n","category":"function"},{"location":"man/interface/#TensorOperations.checkcontractible","page":"Interface","title":"TensorOperations.checkcontractible","text":"checkcontractible(A, iA, conjA, B, iB, conjB, label)\n\nVerify whether two tensors opA(A) and opB(B) are compatible for having their respective index iA and iB contracted, and throws an error if not. The operation opA acts as identity if conjA equals :N and as conj if conjA equals :C; the operation opB is determined by conjB analogously.\n\n\n\n\n\n","category":"function"},{"location":"man/indexnotation/#Index-notation-with-macros","page":"Index notation with macros","title":"Index notation with macros","text":"","category":"section"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The main export and main functionality of TensorOperations.jl is the @tensor macro","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@tensor","category":"page"},{"location":"man/indexnotation/#TensorOperations.@tensor","page":"Index notation with macros","title":"TensorOperations.@tensor","text":"@tensor(tensor_expr; kwargs...)\n@tensor [kw_expr...] tensor_expr\n\nSpecify one or more tensor operations using Einstein's index notation. Indices can be chosen to be arbitrary Julia variable names, or integers. When contracting several tensors together, this will be evaluated as pairwise contractions in left to right order, unless the so-called NCON style is used (positive integers for contracted indices and negative indices for open indices).\n\nAdditional keyword arguments may be passed to control the behavior of the parser:\n\norder:    A list of contraction indices of the form order=(...,) which specify the order in which they will be contracted.\nopt:   Contraction order optimization, similar to @tensoropt. Can be either a boolean or an OptExpr.\ncontractcheck:   Boolean flag to enable runtime check for contractibility of indices with clearer error messages.\ncostcheck:   Can be either :warn or :cache and adds runtime checks to compare the compile-time contraction order to the optimal order computed for the actual run time tensor costs.   If costcheck == :warn, warnings are printed for every sub-optimal contraction that is encountered.   If costcheck == :cache, only the most costly run of a particular sub-optimal contraction will be cached in TensorOperations.costcache.   In both cases, a suggestion for the order keyword argument is computed to switch to the optimal contraction order.\nbackend:    Inserts an implementation backend as a final argument in the different tensor operation calls in the generated code.\nallocator:   Inserts an allocation strategy as a final argument in the tensor allocation calls in the generated code.\n\n\n\n\n\n","category":"macro"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The functionality and configurability of @tensor and some of its relatives is explained in detail on this page.","category":"page"},{"location":"man/indexnotation/#The-@tensor-macro","page":"Index notation with macros","title":"The @tensor macro","text":"","category":"section"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The prefered way to specify (a sequence of) tensor operations is by using the @tensor macro, which accepts an index notation format, a.k.a. Einstein notation (and in particular, Einstein's summation convention).","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"This can most easily be explained using a simple example:","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"using TensorOperations\nα = randn()\nA = randn(5, 5, 5, 5, 5, 5)\nB = randn(5, 5, 5)\nC = randn(5, 5, 5)\nD = zeros(5, 5, 5)\n@tensor begin\n    D[a, b, c] = A[a, e, f, c, f, g] * B[g, b, e] + α * C[c, a, b]\n    E[a, b, c] := A[a, e, f, c, f, g] * B[g, b, e] + α * C[c, a, b]\nend","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The first important observation is the use of two different assignment operators within the body of the @tensor call. The regular assignment operator = stores the result of the tensor expression in the right hand side in an existing tensor D, whereas the 'definition' operator := results in a new tensor E with the correct properties to be created. Nonetheless, the contents of D and E will be equal.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Following Einstein's summation convention, that contents is computed in a number of steps involving the three primitive tensor operators. In this particular example, the first step involves tracing/contracting the 3rd and 5th index of array A, the result of which is stored in a temporary array which thus needs to be created. This resulting array will then be contracted with array B by contracting its 2nd index with the last index of B and its last index with the first index of B. The result is stored in D in the first line, or in a newly allocated array which will end up being E in the second line. Note that the index order of D and E is such that its first index corresponds to the first index of A, the second index corresponds to the second index of B, whereas the third index corresponds to the fourth index of A. Finally, the array C (scaled with α) is added to this result (in place), which requires a further index permutation.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The index pattern is analyzed at compile time and expanded to a set of calls to the basic tensor operations, i.e. tensoradd!, tensortrace! and tensorcontract!. Temporaries are created where necessary, as these building blocks operate pairwise on the input tensors. The generated code can easily be inspected","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"using TensorOperations\n@macroexpand @tensor E[a, b, c] := A[a, e, f, c, f, g] * B[g, b, e] + α * C[c, a, b]","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The different functions in which this tensor expression is decomposed are discussed in more detail in the Implementation section of this manual.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"In this example, the tensor indices were labeled with arbitrary letters; also longer names could have been used. In fact, any proper Julia variable name constitutes a valid label. Note though that these labels are never interpreted as existing Julia variables. Within the @tensor macro they are converted into symbols and then used as dummy names, whose only role is to distinguish the different indices. Their specific value bears no meaning. They also do not appear in the generated code as illustrated above. This implies, in particular, that the specific tensor operations defined by the code inside the @tensor environment are completely specified at compile time. Various remarks regarding the index notation are in order.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"TensorOperations.jl only supports strict Einstein summation convention. This implies  that there are two types of indices. Either an index label appears once in every term of  the right hand side, and it also appears on the left hand side. We refer to the  corresponding indices as open or free. Alternatively, an index label appears exactly  twice within a given term on the right hand side. The corresponding indices are referred  to as closed or contracted, i.e. the pair of indices takes equal values and are summed  over their (equal) range. This is known as a contraction, either an outer contraction  (between two indices of two different tensors) or an inner contraction (a.k.a. trace,  between two indices of a single tensor). More liberal use of the index notation, such as  simultaneous summutation over three or more indices, or a open index appearing  simultaneously in different tensor factors, are not supported by TensorOperations.jl.\nAside from valid Julia identifiers, index labels can also be specified using literal  integer constants or using a combination of integers and symbols. Furthermore, it is  also allowed to use primes (i.e. Julia's adjoint operator) to denote different  indices, including using multiple subsequent primes. The following expression thus  computes the same result as the example above:\n@tensor D[å'', ß, clap'] = A[å'', 1, -3, clap', -3, 2] * B[2, ß, 1] + α * C[clap', å'', ß]\nIf only integers are used for specifying index labels, this can be used to control the  pairwise contraction order, by using the well-known NCON convention, where open indices  in the left hand side are labelled by negative integers -1, -2, -3, whereas  contraction indices are labelled with positive integers 1, 2, … Since the index  order of the left hand side is in that case clear from the right hand side expression,  the left hand side can be indexed with [:], which is automatically replaced with all  negative integers appearing in the right hand side, in decreasing order. The value of  the labels for the contraction indices determines the pairwise contraction order. If  multiple tensors need to be contracted, a first temporary will be created consisting of  the contraction of the pair of tensors that share contraction index 1, then the pair  of tensors that share contraction index 2 (if not contracted away in the first pair)  will be contracted, and so forth. The next subsection explains contraction order in more  detail and gives some useful examples, as the example above only includes a single pair  of tensors to be contracted.\nIndex labels always appear in square brackets [ ... ] but can be separated by either  commas, as in D[a, b, c], (yielding a :ref expression) or by spaces, as in  D[a b c], (yielding a :typed_hcat expression).\nThere is also the option to separate the indices into two groups using a semicolon. This  can be useful for tensor types which have two distinct set of indices, but has no effect  when using Julia AbstractArray objects. While in principle both spaces and commas can  be used within the two groups, e.g. as in D[a, b; c] or D[a b; c], there are some  restrictions because of accepted Julia syntax. Both groups of indices should use the  same convention. If there is only a single index in the first group, the second group  should use spaces to constitute a valid expression. Finally, having no indices in the  first group is only possible by writing an empty tuple. The second group can then use  spaces, or also contain the indices as a tuple, i.e. both D[(); a b c] or D[(); (a,  b, c)]. Writing the two groups of indices within a tuple (which uses a comma as natural  separator), with both tuples seperated by a semicolon is always valid syntax,  irrespective of the number of indices in that group.\nIndex expressions [...] are only interpreted as index notation on the highest level.  For example, if you want to mulitply two matrices which are stored in a list, you can  write\n@tensor result[i,j] := list[1][i,k] * list[2][k,j]\nHowever, if both are stored as a the slices of a 3-way array, you cannot write\n@tensor result[i,j] := list[i,k,1] * list[k,j,2]\nRather, you should use\n@tensor result[i,j] := list[:,:,1][i,k] * list[:,:,2][k,j]\nor, if you want to avoid additional allocations\n@tensor result[i,j] := view(list,:,:,1)[i,k] * view(list,:,:,2)[k,j]","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Note, finally, that the @tensor specifier can be put in front of a single tensor expression, or in front of a begin ... end block to group and evaluate different expressions at once. Within an @tensor begin ... end block, the @notensor macro can be used to annotate indexing expressions that need to be interpreted literally. ","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@notensor","category":"page"},{"location":"man/indexnotation/#TensorOperations.@notensor","page":"Index notation with macros","title":"TensorOperations.@notensor","text":"@notensor(block)\n\nMarks a block which should be ignored within an @tensor environment. Has no effect outside of @tensor.\n\n\n\n\n\n","category":"macro"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"As in illustration, note that the previous code examples about the matrix multiplication with matrices stored in a 3-way array can now also be written as","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@tensor begin\n    @notensor A = list[:,:,1]\n    @notensor B = list[:,:,2]\n    result[i,j] = A[i,k] * B[k,j]\nend","category":"page"},{"location":"man/indexnotation/#Contraction-order-specification-and-optimisation","page":"Index notation with macros","title":"Contraction order specification and optimisation","text":"","category":"section"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"A contraction of several (more than two) tensors, as in","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@tensor D[a, d, j, i, g] := A[a, b, c, d, e] * B[b, e, f, g] * C[c, f, i, j]","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"is known as a tensor network and is generically evaluated as a sequence of pairwise contractions. In the example above, this contraction is evaluated using Julia's default left to right order, i.e. as (A[a, b, c, d, e] * B[b, e, f, g]) * C[c, f, i, j]. There are however different strategies to modify this order.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Explicit parenthesis can be used to group subnetworks within a tensor network that will  be evaluated first. Parentheses around subexpressions are always respected by the  @tensor macro.\nAs explained in the previous subsection, if one respects the  NCON convention of specifying indices, i.e. positive  integers for the contracted indices and negative indices for the open indices, the  different factors will be reordered and so that the pairwise tensor contractions  contract over indices with smaller integer label first. For example,\n@tensor D[:] := A[-1, 3, 1, -2, 2] * B[3, 2, 4, -5] * C[1, 4, -4, -3]\nwill be evaluated as (A[-1, 3, 1, -2, 2] * C[1, 4, -4, -3]) * B[3, 2, 4, -5].  Furthermore, in that case the indices of the output tensor (D in this case) do not  need to be specified (using [:] instead), and will be chosen as  (-1, -2, -3, -4, -5). Note that if two tensors are contracted, all contraction indices  among them will be contracted, even if there are additional contraction indices whose  label is a higher positive number. For example,\n@tensor D[:] := A[-1, 3, 2, -2, 1] * B[3, 1, 4, -5] * C[2, 4, -4, -3]\namounts to the original left to right order, because A and B share the first  contraction index 1. When A and B are contracted, also the contraction with label  3 will be performed, even though contraction index with label 2 is not yet  'processed'.\nA specific contraction order can be manually specified by supplying an order keyword  argument to the @tensor macro. The value is a tuple of the contraction indices in the  order that they should be dealt with, e.g. the default order could be changed to first  contract A with C using\n@tensor order=(c, b, e, f) begin\n    D[a, d, j, i, g] := A[a, b, c, d, e] * B[b, e, f, g] * C[c, f, i, j]\nend\nHere, the same comment as in the NCON style applies; once two tensors are contracted  because they share an index label which is next in the order list, all other indices  with shared label among them will be contracted, irrespective of their order.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"In the case of more complex tensor networks, the optimal contraction order cannot always easily be guessed or determined on plain sight. It is then useful to be able to optimize the contraction order automatically, given a model for the complexity of contracting the different tensors in a particular order. This functionality is provided where the cost function being minimized models the computational complexity by counting the number of scalar multiplications. This minimisation problem is solved using the algorithm that was described in Physical Review E 90, 033315 (2014). For a given tensor networ contraction, this algorithm is ran once at compile time, while lowering the tensor espression, and the outcome will be hard coded in the expression resulting from the macro expansion. While the computational complexity of this optimisation algorithm scales itself exponentially in the number of tensors involved in the network, it should still be acceptibly fast (milliseconds up to a few seconds at most) for tensor network contractions with up to around 30 tensors. Information of the optimization process can be obtained during compilation by using the alternative macro @tensoropt_verbose.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"As the cost is determined at compile time, it is not using actual tensor properties (e.g. size(A, i) in the case of arrays) in the cost model, and the cost or extent associated with every index can be specified in various ways, either using integers or floating point numbers or some arbitrary univariate polynomial of an abstract variable, e.g. χ. In the latter case, the optimization assumes the asymptotic limit of large χ.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@tensoropt\n@tensoropt_verbose","category":"page"},{"location":"man/indexnotation/#TensorOperations.@tensoropt","page":"Index notation with macros","title":"TensorOperations.@tensoropt","text":"@tensoropt(optex, block)\n@tensoropt(block)\n\nSpecify one or more tensor operations using Einstein's index notation. Indices can be chosen to be arbitrary Julia variable names, or integers. When contracting several tensors together, the macro will determine (at compile time) the optimal contraction order depending on the cost associated to the individual indices. If no optex is provided, all indices are assumed to have an abstract scaling χ which is optimized in the asympotic limit of large χ.\n\nThe cost can be specified in the following ways:\n\n# cost χ for all indices (a, b, c, d, e, f)\n@tensoropt D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]\n\n# asymptotic cost χ for indices (a, b, c, e), other indices (d, f) have cost 1\n@tensoropt (a, b, c, e) C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]\n\n# cost 1 for indices (a, b, c, e); other indices (d, f) have asymptotic cost χ\n@tensoropt !(a, b, c, e) C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]\n\n# cost as specified for listed indices, unlisted indices have cost 1 (any symbol for χ can be used)\n@tensoropt (a => χ, b => χ^2, c => 2 * χ, e => 5) begin\n    C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]\nend\n\nNote that @tensoropt will optimize any tensor contraction sequence it encounters in the (block of) expressions. It will however not break apart expressions that have been explicitly grouped with parenthesis, i.e. in\n\n@tensoropt C[a, b, c, d] := A[a, e, c, f, h] * (B[f, g, e, b] * C[g, d, h])\n\nit will always contract B and C first. For a single tensor contraction sequence, the optimal contraction order and associated (asymptotic) cost can be obtained using @optimalcontractiontree.\n\n\n\n\n\n","category":"macro"},{"location":"man/indexnotation/#TensorOperations.@tensoropt_verbose","page":"Index notation with macros","title":"TensorOperations.@tensoropt_verbose","text":"@tensoropt_verbose(optex, block)\n@tensoropt_verbose(block)\n\nSimilar to @tensoropt, but prints information details regarding the optimization process to the standard output.\n\n\n\n\n\n","category":"macro"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"As an final remark, the optimization can also be accessed directly from @tensor by specifying the additional keyword argument opt=true, which will then use the default cost model, or opt=optex to further specify the costs.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"# cost χ for all indices (a, b, c, d, e, f)\n@tensor opt=true D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]\n\n# cost χ for indices (a, b, c, e), other indices (d, f) have cost 1\n@tensor opt=(a, b, c, e) D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]\n\n# cost 1 for indices (a, b, c, e), other indices (d, f) have cost χ\n@tensor opt=!(a, b, c, e) D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]\n\n# cost as specified for listed indices, unlisted indices have cost 1 (any symbol for χ can be used)\n@tensor opt=(a => χ, b => χ^2, c => 2 * χ, e => 5) begin\n    D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]\nend\n","category":"page"},{"location":"man/indexnotation/#Dynamical-tensor-network-contractions-with-ncon-and-@ncon","page":"Index notation with macros","title":"Dynamical tensor network contractions with ncon and @ncon","text":"","category":"section"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Tensor network practicioners are probably more familiar with the network contractor function ncon to perform a tensor network contraction, as e.g. described in NCON. In particular, a graphical application TensorTrace was recently introduced to facilitate the generation of such ncon calls. TensorOperations.jl provides compatibility with this interface by also exposing an ncon function with the same basic syntax","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"ncon(list_of_tensor_objects, list_of_index_lists)","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"e.g. the example of above is equivalent to","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@tensor D[:] := A[-1, 3, 1, -2, 2] * B[3, 2, 4, -5] * C[1, 4, -4, -3]\nD ≈ ncon((A, B, C), ([-1, 3, 1, -2, 2], [3, 2, 4, -5], [1, 4, -4, -3]))","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"where the lists of tensor objects and of index lists can be given as a vector or a tuple. The ncon function necessarily needs to analyze the contraction pattern at runtime, but this can be an advantage, in cases where the contraction is determined by runtime information and thus not known at compile time. A downside from this, besides the fact that this can result in some overhead (though this is typically negligable for anything but very small tensor contractions), is that ncon is type-unstable, i.e. its return type cannot be inferred by the Julia compiler.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The full call syntax of the ncon method exposed by TensorOperations.jl is","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"ncon(tensorlist, indexlist, [conjlist]; order=..., output=...)","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"where the first two arguments are those of above. Let us first discuss the keyword arguments. The keyword argument order can be used to change the contraction order, i.e. by specifying which contraction indices need to be processed first, rather than the strictly increasing order [1, 2, ...], as discussed in the previous subsection. The keyword argument output can be used to specify the order of the output indices, when it is different from the default [-1, -2, ...].","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The optional positional argument conjlist is a list of Bool variables that indicate whether the corresponding tensor needs to be conjugated in the contraction. So while","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"ncon([A, conj(B), C], [[-1, 3, 1, -2, 2], [3, 2, 4, -5], [1, 4, -4, -3]]) ≈\nncon([A, B, C], [[-1, 3, 1, -2, 2], [3, 2, 4, -5], [1, 4, -4, -3]], [false, true, false])","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"the latter has the advantage that conjugating B is not an extra step (which creates an additional temporary requiring allocations), but is performed at the same time when it is contracted.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"As an alternative solution to the optional positional arguments, there is also an @ncon macro. It is just a simple wrapper over an ncon call and thus does not analyze the indices at compile time, so that they can be fully dynamical. However, it will transform","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@ncon([A, conj(B), C], indexlist; order=..., output=...)","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"into","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"ncon(Any[A, B, C], indexlist, [false, true, false]; order=..., output=...)","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"so as to get the advantages of just-in-time conjugation (pun intended) using the familiar looking ncon syntax.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"ncon\n@ncon","category":"page"},{"location":"man/indexnotation/#TensorOperations.ncon","page":"Index notation with macros","title":"TensorOperations.ncon","text":"ncon(tensorlist, indexlist, [conjlist, sym]; order = ..., output = ...)\n\nContract the tensors in tensorlist (of type Vector or Tuple) according to the network as specified by indexlist. Here, indexlist is a list (i.e. a Vector or Tuple) with the same length as tensorlist whose entries are themselves lists (preferably Vector{Int}) where every integer entry provides a label for corresponding index/dimension of the corresponding tensor in tensorlist. Positive integers are used to label indices that need to be contracted, and such thus appear in two different entries within indexlist, whereas negative integers are used to label indices of the output tensor, and should appear only once.\n\nOptional arguments in another list with the same length, conjlist, whose entries are of type Bool and indicate whether the corresponding tensor object should be conjugated (true) or not (false). The default is false for all entries.\n\nBy default, contractions are performed in the order such that the indices being contracted over are labelled by increasing integers, i.e. first the contraction corresponding to label 1 is performed. The output tensor had an index order corresponding to decreasing (negative, so increasing in absolute value) index labels. The keyword arguments order and output allow to change these defaults.\n\nSee also the macro version @ncon.\n\n\n\n\n\n","category":"function"},{"location":"man/indexnotation/#TensorOperations.@ncon","page":"Index notation with macros","title":"TensorOperations.@ncon","text":"@ncon(tensorlist, indexlist; order = ..., output = ...)\n\nContract the tensors in tensorlist (of type Vector or Tuple) according to the network as specified by indexlist. Here, indexlist is a list (i.e. a Vector or Tuple) with the same length as tensorlist whose entries are themselves lists (preferably Vector{Int}) where every integer entry provides a label for corresponding index/dimension of the corresponding tensor in tensorlist. Positive integers are used to label indices that need to be contracted, and such thus appear in two different entries within indexlist, whereas negative integers are used to label indices of the output tensor, and should appear only once.\n\nBy default, contractions are performed in the order such that the indices being contracted over are labelled by increasing integers, i.e. first the contraction corresponding to label 1 is performed. The output tensor had an index order corresponding to decreasing (negative, so increasing in absolute value) index labels. The keyword arguments order and output allow to change these defaults.\n\nThe advantage of the macro @ncon over the function call ncon is that, if tensorlist is not just some variable but an actual list (as a tuple with parentheses or a vector with square brackets) at the call site, the @ncon macro will scan for conjugation calls, e.g. conj(A), and replace this with just A but build a matching list of conjugation flags to be specified to ncon. This makes it more convenient to specify tensor conjugation, without paying the cost of actively performing the conjugation beforehand.\n\nSee also the function ncon.\n\n\n\n\n\n","category":"macro"},{"location":"man/indexnotation/#Index-compatibility-and-checks","page":"Index notation with macros","title":"Index compatibility and checks","text":"","category":"section"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Indices with the same label, either open indices on the two sides of the equation, or contracted indices, need to be compatible. For AbstractArray objects, this means they must have the same size. Other tensor types might have more complicated structure associated with their indices, and requires matching between those. The function checkcontractible is part of the interface that can be used to control when tensors can be contracted with each other along specific indices.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"If indices do not match, the contraction will spawn an error. However, this can be an error deep within the implementation, at which point the error message will provide little information as to which specific tensors and which indices are producing the mismatch. When debugging, it might be useful to add the keyword argument contractcheck = true to the @tensor macro. Explicit checks using checkcontractible are then enabled that are run before any tensor operation is performed. When a mismatch is detected, these checks still have access to the label information and spawn a more informative error message.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"A different type of check is the costcheck keyword argument, which can be given the values :warn or :cache. With either of both values for this keyword argument, additional checks are inserted that compare the contraction order of any tensor contraction of three or more factors against the optimal order based on the current tensor size. More generally, the function tensorcost is part of the interface and associated a cost value with every index of a tensor, which is then used in the cost model. With costcheck=:warn, a warning will be spawned for every tensor network where the actual contraction order (even when optimized using abstract costs) does not match with the ideal contraction order given the current tensorcost values. With costcheck = :cache, the tensor networks with non-optimal contraction order are stored in a global package variable TensorOperations.costcache. However, when a tensor network is evaluated several times with different tensor sizes or tensor costs, only the evaluation giving rise to the largest total contraction cost for that network will appear in the cache (provided the actual contraction order deviates from the optimal order in that largest case).","category":"page"},{"location":"man/indexnotation/#Backends,-multithreading-and-GPUs","page":"Index notation with macros","title":"Backends, multithreading and GPUs","text":"","category":"section"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Every index expression will be evaluated as a sequence of elementary tensor operations, i.e. permuted additions, partial traces and contractions, which are implemented for strided arrays as discussed in Package features. In particular, these implementations rely on Strided.jl, and we refer to this package for a full specification of which arrays are supported. As a rule of thumb, this primarily includes Arrays from Julia base, as well as views thereof if sliced with a combination of Integers and Ranges. Special types such as Adjoint and Transpose from Base are also supported. For permuted addition and partial traces, native Julia implementations are used which could benefit from multithreading if JULIA_NUM_THREADS>1.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The binary contraction is performed by first permuting the two input tensors into a form such that the contraction becomes equivalent to one matrix multiplication on the whole data, followed by a final permutation to bring the indices of the output tensor into the desired order. This approach allows to use the highly efficient matrix multiplication kernel (gemm) from BLAS, which is multithreaded by default. There is also a native contraction implementation that is used for e.g. arrays with an eltype that is not <:LinearAlgebra.BlasFloat. It performs the contraction directly without the additional permutations, but still in a cache-friendly and multithreaded way (again relying on JULIA_NUM_THREADS > 1). This implementation can also be used for BlasFloat types (but will typically be slower), and the use of BLAS can be controlled by explicitly switching the backend between StridedBLAS and StridedNative using the backend keyword to @tensor. Similarly, different allocation strategies, when available, can be selected using the allocator keyword of @tensor.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"The primitive tensor operations are also implemented for CuArray objects of the CUDA.jl library. This implementation is essentially a simple wrapper over the cuTENSOR library of NVidia, and will only be loaded when the cuTENSOR.jl package is loaded. The @tensor macro will then automatically work for operations between GPU arrays.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"Mixed operations between host arrays (e.g. Array) and device arrays (e.g. CuArray) will fail. However, if one wants to harness the computing power of the GPU to perform all tensor operations, there is a dedicated macro @cutensor. This will transfer all host arrays to the GPU before performing the requested operations. If the output is an existing host array, the result will be copied back. If a new result array is created (i.e. using :=), it will remain on the GPU device and it is up to the user to transfer it back. Arrays are transfered to the GPU just before they are first used, and in a complicated tensor expression, this might have the benefit that transer of the later arrays overlaps with computation of earlier operations.","category":"page"},{"location":"man/indexnotation/","page":"Index notation with macros","title":"Index notation with macros","text":"@cutensor","category":"page"},{"location":"man/indexnotation/#TensorOperations.@cutensor","page":"Index notation with macros","title":"TensorOperations.@cutensor","text":"@cutensor tensor_expr\n\nUse the GPU to perform all tensor operations, through the use of the cuTENSOR library. This will transfer all arrays to the GPU before performing the requested operations. If the output is an existing host array, the result will be transferred back. If a new array is created (i.e. using :=), it will remain on the GPU device and it is up to the user to transfer it back. This macro is equivalent to @tensor backend=cuTENSOR allocator=cuTENSOR tensor_expr.\n\nnote: Note\nThis macro requires the cuTENSOR library to be installed and loaded. This can be achieved by running using cuTENSOR or import cuTENSOR before using the macro.\n\n\n\n\n\n","category":"macro"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"CurrentModule = TensorOperations","category":"page"},{"location":"man/implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"CurrentModule = TensorOperations","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The @tensor macro and its relatives work as parsers for indexed tensor expressions. They transform these into a sequence of calls to the primitive tensor operations. This allows the support of custom types that implement the Interface. The actual implementation is achieved through the use of TensorParser, which provides the general framework to parse tensor expressions. The @tensor macro is then just a wrapper around this, which configures the default behavior and handles keyword arguments of the parser.","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The TensorParser works by breaking down the parsing into three main phases. First, a basic check of the supplied expression is performed, to ensure that it is a valid tensor expression. Then, a number of preprocessing steps can be performed, which are used to standardize expressions, allow for syntactic sugar features, and can also be used as a hook for writing custom parsers. Then, the different contractions within the tensor expression are analyzed and processed, which rewrites the expression into a set of binary rooted trees. Then, the main step can be executed, namely transforming the whole expression into actual calls to the primitive tensor operations tensoradd!, tensortrace! and tensorcontract!, as well as calls to tensoralloc_add and tensoralloc_contract to allocate the temporary and final tensors. For those, also the resulting scalar type needs to be determined. Finally, a number of postprocessing steps can be added, which are mostly used to clean up the resulting expression by flattening and by removing line number nodes, but also to incorporate the custom backend and allocation system.","category":"page"},{"location":"man/implementation/#Verifiers","page":"Implementation","title":"Verifiers","text":"","category":"section"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The basic checks are performed by verifytensorexpr, which calls the verifiers isassignment, isdefinition, istensor, istensorexpr and isscalarexpr.","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"TensorOperations.verifytensorexpr\nTensorOperations.isassignment\nTensorOperations.isdefinition\nTensorOperations.isindex\nTensorOperations.istensor\nTensorOperations.istensorexpr\nTensorOperations.isscalarexpr","category":"page"},{"location":"man/implementation/#TensorOperations.verifytensorexpr","page":"Implementation","title":"TensorOperations.verifytensorexpr","text":"verifytensorexpr(ex)\n\nCheck that ex is a valid tensor expression and throw an ArgumentError if not. Valid tensor expressions satisfy one of the following (recursive) rules):\n\nThe expression is a scalar expression or a tensor expression.\nThe expression is an assignment or a definition, and the left hand side and right hand side are valid tensor expressions or scalars.\nThe expression is a block, and all subexpressions are valid tensor expressions or scalars.\n\nSee also istensorexpr and isscalarexpr.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.isassignment","page":"Implementation","title":"TensorOperations.isassignment","text":"isassignment(ex)\n\nTest if ex is an assignment expression, i.e. ex is of one of the forms:\n\na = b\na += b\na -= b\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.isdefinition","page":"Implementation","title":"TensorOperations.isdefinition","text":"isdefinition(ex)\n\nTest if ex is a definition expression, i.e. ex is of the form:\n\na := b\na ≔ b\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.isindex","page":"Implementation","title":"TensorOperations.isindex","text":"isindex(ex)\n\nTest for a valid index, namely a symbol or integer, or an expression of the form i′ where i is itself a valid index.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.istensor","page":"Implementation","title":"TensorOperations.istensor","text":"istensor(ex)\n\nTest for a simple tensor object indexed by valid indices. This means an expression of the form:\n\nA[i, j, k, ...]\nA[i j k ...]\nA[i j k ...; l m ...]\nA[(i, j, k, ...); (l, m, ...)]\n\nwhere i, j, k, ... are valid indices.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.istensorexpr","page":"Implementation","title":"TensorOperations.istensorexpr","text":"istensorexpr(ex)\n\nTest for a tensor expression. This means an expression which can be evaluated to a valid     tensor. This includes:\n\nA[...] + B[...] - C[...] - ...\nA[...] * B[...] * ...\nλ * A[...] / μ\nλ \\ conj(A[...])\nA[...]' + adjoint(B[...]) - ...\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.isscalarexpr","page":"Implementation","title":"TensorOperations.isscalarexpr","text":"isscalarexpr(ex)\n\nTest for a scalar expression, i.e. an expression that can be evaluated to a scalar.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#Preprocessing","page":"Implementation","title":"Preprocessing","text":"","category":"section"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The following functions exist as preprocessors and are enabled in the default TensorParser objects.","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"TensorOperations.normalizeindices\nTensorOperations.expandconj\nTensorOperations.groupscalarfactors\nTensorOperations.nconindexcompletion\nTensorOperations.extracttensorobjects\nTensorOperations.insertcontractionchecks","category":"page"},{"location":"man/implementation/#TensorOperations.normalizeindices","page":"Implementation","title":"TensorOperations.normalizeindices","text":"normalizeindices(ex::Expr)\n\nNormalize indices of an expression by replacing all indices with a prime expression i' by indices with a unicode prime 'i′'.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.expandconj","page":"Implementation","title":"TensorOperations.expandconj","text":"expandconj(ex)\n\nExpand all conj calls in an expression to conjugate the individual terms and factors.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.groupscalarfactors","page":"Implementation","title":"TensorOperations.groupscalarfactors","text":"groupscalarfactors(ex)\n\nGroup all scalar factors of a tensor expression into a single scalar factor at the start of the expression.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.nconindexcompletion","page":"Implementation","title":"TensorOperations.nconindexcompletion","text":"nconindexcompletion(ex)\n\nComplete the indices of the left hand side of an ncon expression. For example, the following expressions are equivalent after index completion.\n\n@tensor A[:] := B[-1, 1, 2] * C[1, 2, -3]\n@tensor A[-1, -2] := B[-1, 1, 2] * C[1, 2, -3]\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.extracttensorobjects","page":"Implementation","title":"TensorOperations.extracttensorobjects","text":"extracttensorobjects(ex)\n\nExtract all tensor objects which are not simple symbols with newly generated symbols, and assign them before the expression and after the expression as necessary, in order to avoid multiple evaluations of the expression constituting the tensor object.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.insertcontractionchecks","page":"Implementation","title":"TensorOperations.insertcontractionchecks","text":"insertcontractionchecks(ex)\n\nInsert runtime checks before each contraction, which provide clearer debug information.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#Processing","page":"Implementation","title":"Processing","text":"","category":"section"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The following functions implement the main steps in parsing the tensor expression, and are always performed by any TensorParser object.","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"TensorOperations.processcontractions\nTensorOperations.tensorify","category":"page"},{"location":"man/implementation/#TensorOperations.processcontractions","page":"Implementation","title":"TensorOperations.processcontractions","text":"processcontractions(ex, treebuilder, treesorter, costcheck)\n\nProcess the contractions in ex using the given treebuilder and treesorter functions. This is done by first extracting a network representation from the expression, then building and sorting the contraction trees with a given treebuilder and treesorter function, and finally inserting the contraction trees back into the expression. When the costcheck argument equals :warn or :cache (as opposed to :nothing), the optimal contraction order is computed at runtime using the actual values of tensorcost and this optimal order is compared to the contraction order that was determined at compile time. If the compile time order deviated from the optimal order, a warning will be printed (in case of costcheck == :warn) or this particular contraction will be recorded in TensorOperations.costcache (in case of costcheck == :cache). Both the warning or the  recorded cache entry contain a order suggestion that can be passed to the @tensor macro in order to encode the optimal contraction order at compile time..\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.tensorify","page":"Implementation","title":"TensorOperations.tensorify","text":"tensorify(ex)\n\nMain parsing step to transform a tensor expression ex into a series of function calls associated with the primitive building blocks (tensor operations and allocations).\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#Postprocessing","page":"Implementation","title":"Postprocessing","text":"","category":"section"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The following functions exist as postprocessors and are enabled in the default TensorParser objects.","category":"page"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"TensorOperations._flatten\nTensorOperations.removelinenumbernode\nTensorOperations.addtensoroperations\nTensorOperations.insertbackend","category":"page"},{"location":"man/implementation/#TensorOperations._flatten","page":"Implementation","title":"TensorOperations._flatten","text":"_flatten(ex)\n\nFlatten nested structure of an expression, returning an unnested Expr(:block, …).\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.removelinenumbernode","page":"Implementation","title":"TensorOperations.removelinenumbernode","text":"removelinenumbernode(ex)\n\nRemove all LineNumberNodes from an expression.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.addtensoroperations","page":"Implementation","title":"TensorOperations.addtensoroperations","text":"addtensoroperations(ex)\n\nFix references to TensorOperations functions in namespaces where @tensor is present but the functions are not.\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#TensorOperations.insertbackend","page":"Implementation","title":"TensorOperations.insertbackend","text":"insertbackend(ex, backend, operations)\n\nInsert a backend into a tensor operation, e.g. for any op ∈ operations, transform TensorOperations.op(args...) -> TensorOperations.op(args..., Backend{:backend}())\n\n\n\n\n\n","category":"function"},{"location":"man/implementation/#Analysis-of-contraction-graphs-and-optimizing-contraction-order","page":"Implementation","title":"Analysis of contraction graphs and optimizing contraction order","text":"","category":"section"},{"location":"man/implementation/","page":"Implementation","title":"Implementation","text":"The macro @tensoropt or the combination of @tensor with the keyword opt can be used to optimize the contraction order of the expression at compile time. This is done by analyzing the contraction graph, where the nodes are the tensors and the edges are the contractions, in combination with the data provided in optdata, which is a dictionary associating a cost (either a number or a polynomial in some abstract scaling parameter) to every index. This information is then used to determine the (asymptotically) optimal contraction tree (in terms of number of floating point operations). The algorithm that is used is described in arXiv:1304.6112.","category":"page"},{"location":"#TensorOperations.jl","page":"Home","title":"TensorOperations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast tensor operations using a convenient Einstein index notation.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"man/indexnotation.md\", \"man/functions.md\", \"man/autodiff.md\", \"man/interface.md\", \"man/implementation.md\"]\nDepth = 4","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install with the package manager, pkg> add TensorOperations.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The TensorOperations.jl package is centered around the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A macro @tensor for conveniently specifying tensor contractions and index permutations via Einstein's index notation convention. The index notation is analyzed at compile time and lowered into primitive tensor operations, namely (permuted) linear combinations and inner and outer contractions. The macro supports several keyword arguments to customize the lowering process, namely to insert additional checks that help with debugging, to specify contraction order or to automatically determine optimal contraction order for given costs (see next bullet), and finally, to select different backends to evaluate those primitive operations.\nThe ability to optimize pairwise contraction order in complicated tensor contraction networks according to the algorithm in this paper, where custom (compile time) costs can be specified, either as a keyword to @tensor or using the @tensoropt macro (for expliciteness and backward compatibility). This optimization is performed at compile time, and the resulting contraction order is hard coded into the resulting expression. The similar macro @tensoropt_verbose provides more information on the optimization process.\nA function ncon (for network contractor) for contracting a group of tensors (a.k.a. a tensor network), as well as a corresponding @ncon macro that simplifies and optimizes this slightly. Unlike the previous macros, ncon and @ncon do not analyze the contractions at compile time, thus allowing them to deal with dynamic networks or index specifications.\n(Experimental) support for automatic differentiation by supplying chain rules for the different tensor operations using the ChainRules.jl interface.\nThe ability to support different tensor types by overloading a minimal interface of tensor operations, or to support different implementation backends for the same tensor type.\nAn efficient default implementation for Julia Base arrays that qualify as strided, i.e. such that its entries are layed out according to a regular pattern in memory. The only exceptions are ReinterpretedArray objects. Additionally, Diagonal objects whose underlying diagonal data is stored as a strided vector are supported. This facilitates tensor contractions where one of the operands is e.g. a diagonal matrix of singular values or eigenvalues, which are returned as a Vector by Julia's eigen or svd method. This implementation for AbstractArray objects is based on Strided.jl for efficient (cache-friendly and multithreaded) tensor permutations (transpositions) and gemm from BLAS for contractions. There is also a fallback contraction strategy that is natively built using Strided.jl, e.g. for scalar types which are not supported by BLAS. Additional backends (e.g. pure Julia Base using loops and/or broadcasting) may be added in the future.\nSupport for CuArray objects if used together with CUDA.jl and cuTENSOR.jl, by relying on (and thus providing a high level interface into) NVidia's cuTENSOR library.","category":"page"},{"location":"#Tensor-operations","page":"Home","title":"Tensor operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorOperations.jl supports 3 basic tensor operations, i.e. primitives in which every more complicated tensor expression is deconstructed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"addition: Add a (possibly scaled version of) one tensor to another tensor, where the indices of both arrays might appear in different orders. This operation combines normal tensor addition (or linear combination more generally) and index permutation. It includes as a special case copying one tensor into another with permuted indices.\ntrace or inner contraction: Perform a trace/contraction over pairs of indices of a single tensor array, where the result is a lower-dimensional array.\n(outer) contraction: Perform a general contraction of two tensors, where some indices of one array are paired with corresponding indices in a second array.","category":"page"},{"location":"#To-do-list","page":"Home","title":"To do list","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add more backends, e.g. using pure Julia Base functionality, or using LoopVectorization.jl\nMake it easier to modify the contraction order algorithm or its cost function (e.g. to optimize based on memory footprint) or to splice in runtime information.","category":"page"},{"location":"man/autodiff/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"man/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"TensorOperations offers experimental support for reverse-mode automatic diffentiation (AD) through the use of ChainRules.jl. As the basic operations are multi-linear, the vector-Jacobian products thereof can all be expressed in terms of the operations defined in VectorInterface and TensorOperations. Thus, any custom type whose tangent type also support these interfaces will automatically inherit reverse-mode AD support.","category":"page"},{"location":"man/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"As the @tensor macro rewrites everything in terms of the basic tensor operations, the reverse-mode rules for these methods are supplied. However, because most AD-engines do not support in-place mutation, effectively these operations will be replaced with a non-mutating version. This is similar to the behaviour found in BangBang.jl, as the operations will be in-place, except for the pieces of code that are being differentiated. In effect, this amounts to replacing all assignments (=) with definitions (:=) within the context of @tensor.","category":"page"},{"location":"man/autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"warning: Experimental\nWhile some rudimentary tests are run, the AD support is currently not incredibly well-tested. Because of the way it is implemented, the use of AD will tacitly replace mutating operations with a non-mutating variant. This might lead to unwanted bugs that are hard to track down. Additionally, for mixed scalar types their also might be unexpected or unwanted behaviour.","category":"page"},{"location":"man/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The elementary tensor operations can also be accessed via functions, mainly for compatibility with older versions of this toolbox. The function-based syntax is also required when the contraction pattern is not known at compile time but is rather determined dynamically.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The basic exposed interface, as listed below, makes use of any iterable IA, IB or IC to denote labels of indices, in a similar fashion as when used in the context of @tensor. When making use of this functionality, in-place operations are no longer supported, as these are reserved for the expert mode. Note that the return type is only inferred when the labels are entered as tuples, and also IC is specified.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The expert mode exposes both mutating and non-mutating versions of these functions. In this case, selected indices are determined through permutations, specified by pA, pB and pC. In order to distinguish from the non-mutating version in simple mode, overlapping functionality is distinguished by specializing on these permutations, which are required to take a particular form of the type Index2Tuple.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Index2Tuple","category":"page"},{"location":"man/functions/#TensorOperations.Index2Tuple","page":"Functions","title":"TensorOperations.Index2Tuple","text":"Index2Tuple{N₁,N₂} = Tuple{NTuple{N₁,Int},NTuple{N₂,Int}}\n\nA specification of a permutation of N₁ + N₂ indices that are partitioned into N₁ left and N₂ right indices.\n\n\n\n\n\n","category":"type"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"The motivation for this particular convention for specifying permutations comes from the fact that for many operations, it is useful to think of a tensor as a linear map or matrix, in which its different indices are partioned into two groups, the first of which correspond to the range of the linear map (the row index of the associated matrix), whereas the second group corresponds to the domain of the linear map (the column index of the associated matrix). This is most obvious for tensor contraction, which then becomes equivalent to matrix multiplication (which is also how it is implemented by the StridedBLAS backend). While less relevant for tensor permutations, we use this convention throughout for uniformity and generality (e.g. for compatibility with libraries that always represent tensors as linear maps, such as TensorKit.jl).","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Note, finally, that only the expert mode call style exposes the ability to select custom backends.","category":"page"},{"location":"man/functions/#Non-mutating-functions","page":"Functions","title":"Non-mutating functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"tensorcopy\ntensoradd\ntensortrace\ntensorcontract\ntensorproduct","category":"page"},{"location":"man/functions/#TensorOperations.tensorcopy","page":"Functions","title":"TensorOperations.tensorcopy","text":"tensorcopy([IC=IA], A, IA, [conjA=:N, [α=true]])\ntensorcopy(pC::Index2Tuple, A, conjA, α) # expert mode\n\nCreate a copy of A, where the dimensions of A are assigned indices from the iterable IA and the indices of the copy are contained in IC. Both iterables should contain the same elements, optionally in a different order.\n\nThe result of this method is equivalent to α * permutedims(A, pC) where pC is the permutation such that IC = IA[pC]. The implementation of tensorcopy is however more efficient on average, especially if Threads.nthreads() > 1.\n\nOptionally, the symbol conjA can be used to specify whether the input tensor should be conjugated (:C) or not (:N).\n\nSee also tensorcopy!.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensoradd","page":"Functions","title":"TensorOperations.tensoradd","text":"tensoradd([IC=IA], A, IA, [conjA], B, IB, [conjB], [α=true, [β=true]])\ntensoradd(A, pA::Index2Tuple, conjA, B, pB::Index2Tuple, pB::Index2Tuple, conjB, α=true, β=true, [backend]) # expert mode\n\nReturn the result of adding arrays A and B where the iterables IA and IB denote how the array data should be permuted in order to be added. More specifically, the result of this method is equivalent to α * permutedims(A, pA) + β * permutedims(B, pB) where pA (pB) is the permutation such that IC = IA[pA] (IB[pB]). The implementation of tensoradd is however more efficient on average, as the temporary permuted arrays are not created.\n\nOptionally, the symbols conjA and conjB can be used to specify whether the input tensors should be conjugated (:C) or not (:N).\n\nSee also tensoradd!.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensortrace","page":"Functions","title":"TensorOperations.tensortrace","text":"tensortrace([IC], A, IA, [conjA], [α=true])\ntensortrace(pC::Index2Tuple, A, pA::Index2Tuple, conjA, α=true, [backend]) # expert mode\n\nTrace or contract pairs of indices of tensor A, by assigning them identical indices in the iterable IA. The untraced indices, which are assigned a unique index, can be reordered according to the optional argument IC. The default value corresponds to the order in which they appear. Note that only pairs of indices can be contracted, so that every index in IA can appear only once (for an untraced index) or twice (for an index in a contracted pair).\n\nOptionally, the symbol conjA can be used to specify that the input tensor should be conjugated.\n\nSee also tensortrace!.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensorcontract","page":"Functions","title":"TensorOperations.tensorcontract","text":"tensorcontract([IC], A, IA, [conjA], B, IB, [conjB], [α=true])\ntensorcontract(pC::Index2Tuple, A, pA::Index2Tuple, conjA, B, pB::Index2Tuple, conjB, α=true, [backend]) # expert mode\n\nContract indices of tensor A with corresponding indices in tensor B by assigning them identical labels in the iterables IA and IB. The indices of the resulting tensor correspond to the indices that only appear in either IA or IB and can be ordered by specifying the optional argument IC. The default is to have all open indices of A followed by all open indices of B. Note that inner contractions of an array should be handled first with tensortrace, so that every label can appear only once in IA or IB seperately, and once (for an open index) or twice (for a contracted index) in the union of IA and IB.\n\nOptionally, the symbols conjA and conjB can be used to specify that the input tensors should be conjugated.\n\nSee also tensorcontract!.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensorproduct","page":"Functions","title":"TensorOperations.tensorproduct","text":"tensorproduct([IC], A, IA, [conjA], B, IB, [conjB], [α=true])\ntensorproduct(pC::Index2Tuple, A, pA::Index2Tuple, conjA, B, pB::Index2Tuple, conjB, α=true, [backend]) # expert mode\n\nCompute the tensor product (outer product) of two tensors A and B, i.e. returns a new tensor C with ndims(C) = ndims(A) + ndims(B). The indices of the output tensor are related to those of the input tensors by the pattern specified by the indices. Essentially, this is a special case of tensorcontract with no indices being contracted over. This method checks whether the indices indeed specify a tensor product instead of a genuine contraction.\n\nOptionally, the symbols conjA and conjB can be used to specify that the input tensors should be conjugated.\n\nSee also tensorproduct! and tensorcontract.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#Mutating-functions","page":"Functions","title":"Mutating functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"tensorcopy!\ntensoradd!\ntensortrace!\ntensorcontract!\ntensorproduct!","category":"page"},{"location":"man/functions/#TensorOperations.tensorcopy!","page":"Functions","title":"TensorOperations.tensorcopy!","text":"tensorcopy!(C, pC::Index2Tuple, A, conjA=:N, α=true, [backend])\n\nCopy the contents of tensor A into C, where the dimensions A are permuted according to the permutation and repartition pC.\n\nThe result of this method is equivalent to α * permutedims!(C, A, pC).\n\nOptionally, the symbol conjA can be used to specify whether the input tensor should be conjugated (:C) or not (:N).\n\nwarning: Warning\nThe object C must not be aliased with A.\n\nSee also tensorcopy and tensoradd!\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensoradd!","page":"Functions","title":"TensorOperations.tensoradd!","text":"tensoradd!(C, pC, A, conjA, α=true, β=true [, backend])\n\nCompute C = β * C + α * permutedims(opA(A), pC) without creating the intermediate temporary. The operation opA acts as identity if conjA equals :N and as conj if conjA equals :C. Optionally specify a backend implementation to use.\n\nwarning: Warning\nThe permutation needs to be trivial or C must not be aliased with A.\n\nSee also tensoradd.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensortrace!","page":"Functions","title":"TensorOperations.tensortrace!","text":"tensortrace!(C, pC, A, pA, conjA, α=true, β=false [, backend])\n\nCompute C = β * C + α * permutedims(partialtrace(opA(A)), pC) without creating the intermediate temporary, where A is partially traced, such that indices in pA[1] are contracted with indices in pA[2], and the remaining indices are permuted according to pC. The operation opA acts as identity if conjA equals :N and as conj if conjA equals :C. Optionally specify a backend implementation to use.\n\nwarning: Warning\nThe object C must not be aliased with A.\n\nSee also tensortrace.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensorcontract!","page":"Functions","title":"TensorOperations.tensorcontract!","text":"tensorcontract!(C, pC, A, pA, conjA, B, pB, conjB, α=true, β=false [, backend])\n\nCompute C = β * C + α * permutedims(contract(opA(A), opB(B)), pC) without creating the intermediate temporary, where A and B are contracted such that the indices pA[2] of A are contracted with indices pB[1] of B. The remaining indices (pA[1]..., pB[2]...) are then permuted according to pC. The operation opA acts as identity if conjA equals :N and as conj if conjA equals :C; the operation opB is determined by conjB analogously. Optionally specify a backend implementation to use.\n\nwarning: Warning\nThe object C must not be aliased with A or B.\n\nSee also tensorcontract.\n\n\n\n\n\n","category":"function"},{"location":"man/functions/#TensorOperations.tensorproduct!","page":"Functions","title":"TensorOperations.tensorproduct!","text":"tensorproduct!(C, pC::Index2Tuple, A, pA::Index2Tuple, conjA, B, pB::Index2Tuple, conjB, α=true, β=false)\n\nCompute the tensor product (outer product) of two tensors A and B, i.e. a wrapper of tensorcontract! with no indices being contracted over. This method checks whether the indices indeed specify a tensor product instead of a genuine contraction.\n\nwarning: Warning\nThe object C must not be aliased with A or B.\n\nSee als tensorproduct and tensorcontract!.\n\n\n\n\n\n","category":"function"}]
}
