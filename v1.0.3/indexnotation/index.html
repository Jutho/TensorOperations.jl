<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index notation with @tensor macro · TensorOperations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TensorOperations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Home</span><ul><li><a class="toctext" href="../">TensorOperations.jl</a></li><li class="current"><a class="toctext" href>Index notation with <code>@tensor</code> macro</a><ul class="internal"></ul></li><li><a class="toctext" href="../functions/">Functions</a></li><li><a class="toctext" href="../cache/">Cache for temporaries</a></li><li><a class="toctext" href="../implementation/">Implementation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Home</li><li><a href>Index notation with <code>@tensor</code> macro</a></li></ul><a class="edit-page" href="https://github.com/Jutho/TensorOperations.jl/blob/master/docs/src/indexnotation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Index notation with @tensor macro</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Index-notation-with-@tensor-macro-1" href="#Index-notation-with-@tensor-macro-1">Index notation with <code>@tensor</code> macro</a></h1><p>The prefered way to specify (a sequence of) tensor operations is by using the <code>@tensor</code> macro, which accepts an <a href="https://en.wikipedia.org/wiki/Abstract_index_notation">index notation</a> format, a.k.a. <a href="https://en.wikipedia.org/wiki/Einstein_notation">Einstein notation</a> (and in particular, Einstein&#39;s summation convention).</p><p>This can most easily be explained using a simple example:</p><pre><code class="language-julia">using TensorOperations
α=randn()
A=randn(5,5,5,5,5,5)
B=randn(5,5,5)
C=randn(5,5,5)
D=zeros(5,5,5)
@tensor begin
    D[a,b,c] = A[a,e,f,c,f,g]*B[g,b,e] + α*C[c,a,b]
    E[a,b,c] := A[a,e,f,c,f,g]*B[g,b,e] + α*C[c,a,b]
end</code></pre><p>In the second to last line, the result of the operation will be stored in the preallocated array <code>D</code>, whereas the last line uses a different assignment operator <code>:=</code> in order to define a new array <code>E</code> of the correct size. The contents of <code>D</code> and <code>E</code> will be equal.</p><p>Following Einstein&#39;s summation convention, the result is computed by first tracing/ contracting the 3rd and 5th index of array <code>A</code>. The resulting array will then be contracted with array <code>B</code> by contracting its 2nd index with the last index of <code>B</code> and its last index with the first index of <code>B</code>. The resulting array has three remaining indices, which correspond to the indices <code>a</code> and <code>c</code> of array <code>A</code> and index <code>b</code> of array <code>B</code> (in that order). To this, the array <code>C</code> (scaled with <code>α</code>) is added, where its first two indices will be permuted to fit with the order <code>a,c,b</code>. The result will then be stored in array <code>D</code>, which requires a second permutation to bring the indices in the requested order <code>a,b,c</code>.</p><p>In this example, the labels were specified by arbitrary letters or even longer names. Any valid variable name is valid as a label. Note though that these labels are never interpreted as existing Julia variables, but rather are converted into symbols by the <code>@tensor</code> macro. This means, in particular, that the specific tensor operations defined by the code inside the <code>@tensor</code> environment are completely specified at compile time. Alternatively, one can also choose to specify the labels using literal integer constants, such that also the following code specifies the same operation as above. Finally, it is also allowed to use primes (i.e. Julia&#39;s <code>adjoint</code> operator) to denote different indices, including using multiple subsequent primes.</p><pre><code class="language-julia">@tensor D[å&#39;&#39;,ß,c&#39;] = A[å&#39;&#39;,1,-3,c&#39;,-3,2]*B[2,ß,1] + α*C[c&#39;,å&#39;&#39;,ß]</code></pre><p>The index pattern is analyzed at compile time and expanded to a set of calls to the basic tensor operations, i.e. <a href="@ref"><code>add!</code></a>, <a href="@ref"><code>trace!</code></a> and <a href="@ref"><code>contract!</code></a>. Temporaries are created where necessary, but will by default be saved to a global cache, so that they can be reused upon a next iteration or next call to the function in which the <code>@tensor</code> call is used. When experimenting in the REPL where every tensor expression is only used a single time, it might be better to use <code>disable_cache()</code>, though no real harm comes from using the cache (except higher memory usage). By default, the cache is allowed to take up to 50% of the total machine memory, though this is fully configurable.</p><p>A contraction of several tensors <code>A[a,b,c,d,e]*B[b,e,f,g]*C[c,f,i,j]*...</code> is evaluted using pairwise contractions, using Julia&#39;s default left to right order, i.e. as <code>( (A[a,b,c,d,e] * B[b,e,f,g]) * C[c,f,i,j]) * ...</code>. However, if one respects the so-called <a href="https://arxiv.org/abs/1402.0939">NCON</a> style of specifying indices, i.e. positive integers for the contracted indices and negative indices for the open indices, the different factors will be reordered and so that the pairwise tensor contractions contract over indices with smaller integer label first. For example,</p><pre><code class="language-julia">D[:] := A[-1,3,1,-2,2]*B[3,2,4,-5]*C[1,4,-4,-3]</code></pre><p>will be evaluated as <code>(A[-1,3,1,-2,2]*C[1,4,-4,-3])*B[3,2,4,-5]</code>. Furthermore, in that case the indices of the output tensor (<code>D</code> in this case) do not need to be specified (using <code>[:]</code> instead), and will be chosen as <code>(-1,-2,-3,-4,-5)</code>. Any other order is of course still possible by just specifying it.</p><p>Furthermore, there is a <code>@tensoropt</code> macro which will optimize the contraction order to minimize the total number of multiplications (cost model might change or become configurable in the future). The optimal contraction order will be determined at compile time and will be hard coded in the macro expansion. The cost/size of the different indices can be specified in various ways, and can be integers or some arbitrary polynomial of an abstract variable, e.g. <code>χ</code>. In the latter case, the optimization assumes the assymptotic limit of large <code>χ</code>.</p><pre><code class="language-julia">@tensoropt D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost χ for all indices (a,b,c,d,e,f)
@tensoropt (a,b,c,e) D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost χ for indices a,b,c,e, other indices (d,f) have cost 1
@tensoropt !(a,b,c,e) D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost 1 for indices a,b,c,e, other indices (d,f) have cost χ
@tensoropt (a=&gt;χ,b=&gt;χ^2,c=&gt;2*χ,e=&gt;5) D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost as specified for listed indices, unlisted indices have cost 1 (any symbol for χ can be used)</code></pre><p>The optimal contraction tree as well as the associated cost can be obtained by</p><pre><code class="language-julia">@optimalcontractiontree C[a,b,c,d] := A[a,e,c,f]*B[f,d,e,b]</code></pre><p>where the cost of the indices can be specified in the same various ways as for <code>@tensoropt</code>.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">TensorOperations.jl</span></a><a class="next" href="../functions/"><span class="direction">Next</span><span class="title">Functions</span></a></footer></article></body></html>
