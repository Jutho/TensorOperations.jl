<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation · TensorOperations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="TensorOperations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TensorOperations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">TensorOperations.jl</a></li><li><a class="tocitem" href="../indexnotation/">Index notation with macros</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../cache/">Cache for temporaries</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#Index-notation-and-the-@tensor-macro"><span>Index notation and the <code>@tensor</code> macro</span></a></li><li><a class="tocitem" href="#Building-blocks"><span>Building blocks</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Home</a></li><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorOperations.jl/blob/master/docs/src/implementation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h1><p>** Warning: this section still needs to be updated for version 2.0 **</p><h2 id="Index-notation-and-the-@tensor-macro"><a class="docs-heading-anchor" href="#Index-notation-and-the-@tensor-macro">Index notation and the <code>@tensor</code> macro</a><a id="Index-notation-and-the-@tensor-macro-1"></a><a class="docs-heading-anchor-permalink" href="#Index-notation-and-the-@tensor-macro" title="Permalink"></a></h2><p>We start by describing the implementation of the <code>@tensor</code> and <code>@tensoropt</code> macro. The macros end up transforming the index expression to the corresponding function calls to the primitive building blocks, which are discussed in the next section. In principle, anyone interested in making the <code>@tensor</code> macro work for custom array types should only reimplement these building blocks, but it is useful to understand how the tensor expressions are processed.</p><h3 id="Tensors,-a.k.a-indexed-objects"><a class="docs-heading-anchor" href="#Tensors,-a.k.a-indexed-objects">Tensors, a.k.a indexed objects</a><a id="Tensors,-a.k.a-indexed-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Tensors,-a.k.a-indexed-objects" title="Permalink"></a></h3><p>The central objects in tensor expressions that follow the <code>@tensor</code> macro are the index expressions of the form <code>A[a,b,c]</code>.  These are detected as subexpressions of the form <code>Expr(:ref, args)</code>. In fact, what is recognized by <code>@tensor</code> as an indexed object is more general, and also includes expressions of the form <code>A[a b c]</code> or <code>A[a b; c d e]</code> (<code>Expr(:typed_hcat, args)</code> and <code>Expr(:typed_vcat, args)</code>). The last form in particular is useful in more general contexts, and allows to distinguish between two sets of indices, referred to as left (<code>a</code> and <code>b</code>) and right (<code>c</code>, <code>d</code> and <code>e</code>) indices. This can be used when the <code>@tensor</code> macro wants to be generalized to user types, which for example distinguish between contravariant (upper) and covariant (lower) indices. For <code>AbstractArray</code> subtypes, such distinction is of course meaningless.</p><p>Note that the object being indexed, i.e. <code>A</code> in all of the above examples or <code>args[1]</code> in the corresponding <code>Expr</code> objects, can itself be an expression, that is not further analyzed. In particular, this may itself contain further indexing objects, such that one can get tensor objects from a list, e.g. <code>list[3][a,b,c]</code> or slice an array before using it in the <code>@tensor</code> expression, e.g. <code>A[1:2:end,:,3:end][a,b,c]</code>.</p><p>Everything appearing in the <code>[ ]</code>, e.g. <code>args[2:end]</code> (in case of <code>:ref</code> or <code>:typed_hcat</code>, the argument structure of <code>:typed_vcat</code> is slightly more complicated) is considered to be a valid index. This can be any valid Julia variable name, which is just kept as symbol, or any literal integer constant, (for legacy reasons, any literal character constant,) or finally an <code>Expr(Symbol(&quot;&#39;&quot;),args)</code>, i.e. an expression of the form <code>:(a&#39;)</code>. The latter is converted to a symbol of the form <code>Symbol(&quot;a′&quot;)</code> when <code>a</code> is itself a symbol or integer, or this is applied recursively if <code>a</code> contains more primes.</p><p>The implementation for detecting tensors and indices (<code>istensor</code>, <code>isindex</code>) and actually converting them to a useful format (<code>maketensor</code>, <code>makeindex</code>) are found in <code>src/indexnotation/tensorexpressions.jl</code>. In particular, <code>maketensor</code> will return the indexed object, which is just <code>esc(args[1])</code>, the list of left indices and the list of right indices.</p><p>Furthermore, there is <code>isscalar</code> and <code>makescalar</code> to detect and process subexpressions that will evaluate to a scalar. Finally, there is <code>isgeneraltensor</code> and <code>makegeneraltensor</code> to detect and process a a tensor (indexed object), that is possibly conjugated or multiplied with a scalar. This is useful because the primitive tensor operations (i.e. see <a href="#Building-blocks">Building blocks</a> below), accept a scalar factor and conjugation flag, so that these operations can be done simultaneously and do not need to be evaluated at first (which would require additional temporaries). The function <code>makegeneraltensor</code> in particular will return the indexed object, the list of left indices, the list of right indices, the scalar factor, and a flag (<code>Bool</code>) that indicates whether the object needs to be conjugated (<code>true</code>) or not (<code>false</code>).</p><p>The file <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/indexnotation/tensorexpressions.jl"><code>src/indexnotation/tensorexpressions.jl</code></a> also contains simple methods to detect assignment (<code>isassignment</code>) into existing objects (i.e. <code>=</code>, <code>+=</code> and <code>-=</code>) or so-called definitions (<code>isdefinition</code>), that create a new object (via <code>:=</code> or its Unicode variant <code>≔</code>, obtained as <code>\coloneq + TAB</code>). The function <code>getlhsrhs</code> will return the left hand side and right hand side of an assignment or definition expression separately.</p><p>Finally, there are methods to detect whether the right hand side is a valid tensor expression (<code>istensorexpr</code>) and to get the indices of a complete tensor expressions. In particular,  <code>getindices</code> returns a list of indices that will remain after the expression is evaluated (i.e. any index that is not contracted in the expression because it only appears once), whereas <code>getallindices</code> returns a list of all indices that appear in the expression. The latter is used to analyze complete tensor contraction graphs.</p><h3 id="The-macros-@tensor-and-@tensoropt"><a class="docs-heading-anchor" href="#The-macros-@tensor-and-@tensoropt">The macros <code>@tensor</code> and <code>@tensoropt</code></a><a id="The-macros-@tensor-and-@tensoropt-1"></a><a class="docs-heading-anchor-permalink" href="#The-macros-@tensor-and-@tensoropt" title="Permalink"></a></h3><p>Actual processing of the complete expression that follows the <code>@tensor</code> macro and converting it into a list of actual calls to the primitive tensor operations is handled by the functions defined in <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/indexnotation/tensormacro.jl"><code>src/indexnotation/tensormacro.jl</code></a>. The integral expression received by the <code>@tensor</code> macro is passed on to the <code>tensorify</code> function. The <code>@tensoropt</code> macro will first generate the data required to optimize contraction order, by calling <code>optdata</code>. If no actual costs are specified, i.e. <code>@tensoropt</code> receives a single expression, then <code>optdata</code> just assigns the same cost to all indices in the expression. Otherwise, the expression that specifies the costs need to be parsed first (<code>parsecost</code>). Finally, <code>@tensoropt</code> also calls <code>tensorify</code> passing the optdata as a second optional argument (whose default value <code>nothing</code> is used by <code>@tensor</code>).</p><p>The function <code>tensorify</code> consists of several steps. Firstly, it canonicalizes the expression. Currently, this involves a single pass which expands all <code>conj</code> calls of e.g. products or sums to a <code>conj</code> call on each of the arguments (via the <code>expandconj</code> function). Secondly, <code>tensorify</code> will process the contraction order using <code>processcontractorder</code>. This starts from the fact that a product of several tensors, specified as <code>A[...]*B[...]*C[...]</code> yields a single <code>Expr(:call,[:*,...])</code> object where all the factors are still together. If a user wants a specific order, he can do so by grouping them with parenthesis. Whenever an expression <code>Expr(:call,[:*,...])</code> is found where more than two of the arguments satisfy <code>isgeneraltensor</code>, <code>processcontractorder</code> will convert it into a nested set of pairwise multiplications according to a number of strategies discussed in the next subsection.</p><p>The major part of <code>tensorify</code> is to generate the correct function calls corresponding to the tensor expression. It detects assignments or definitions (the most common case) and validates the left hand side thereof (i.e. it should satisfy <code>istensor</code> and have no duplicate indices). Then, it generates the corresponding function calls corresponding to the index expression by passing onto the <code>deindexify</code> function, which takes the signature <code>julia deindexify(dst, β, ex, α, leftind, rightind, istemporary = false)</code> Here, <code>dst</code> is the symbol or expression corresponding to the destination object; it&#39;s <code>nothing</code> in case of a definition (<code>:=</code>), i.e. if the object corresponding to the result needs to be created/allocated. <code>β</code> and <code>α</code> are <code>isscalar</code> expressions, and <code>deindexify</code> will create the function calls required to update <code>dst</code> with multiplying <code>dst</code> with <code>β</code> and adding <code>α</code> times the result of the expression <code>ex</code> to it; this is supported as a one step process by each of the primitive operations. <code>leftind</code> and <code>rightind</code> correspond to the list of indices of the left hand side of the defition or assignment. The final argument <code>istemporary</code> indicates, if <code>dst == nothing</code> and a new object needs to be created/allocated, whether it is a temporary object. If <code>istemporary == true</code>, it can be stored in the cache and later retrieved. If <code>istemporary == false</code>, it corresponds to an explicit left hand side created by the user in a definition, and should not be in the cache.</p><p>The function <code>deindexify</code> will determine the top level operation represented by <code>ex</code> (which should be a <code>istensorexpr</code>), and then pass on to  <code>deindexify_generaltensor</code>, <code>deindexify_linearcombination</code>, <code>deindexify_contraction</code> for actually creating the correct function call expressions. If any of the arguments of e.g. a linear combination or a tensor contraction is itself a composite tensor expression (i.e. not a <code>isgeneraltensor</code>), <code>deindexify</code> is called recursively.</p><h3 id="Analyzing-contraction-graphs-(a.k.a-tensor-networks)-and-optimizing-contraction-order"><a class="docs-heading-anchor" href="#Analyzing-contraction-graphs-(a.k.a-tensor-networks)-and-optimizing-contraction-order">Analyzing contraction graphs (a.k.a tensor networks) and optimizing contraction order</a><a id="Analyzing-contraction-graphs-(a.k.a-tensor-networks)-and-optimizing-contraction-order-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-contraction-graphs-(a.k.a-tensor-networks)-and-optimizing-contraction-order" title="Permalink"></a></h3><p>The function <code>processcontractorder</code>, which is excuted before the index expression is converted to function calls, will detect any multiplication with more than two <code>isgeneraltensor</code> factors, and divide it up into a nested sequence of pairwise multiplications (tensor contractions), i.e. a tree. If the <code>@tensor</code> macro was used, <code>optdata = nothing</code> and in principle the multiplication will be performed from left to right. There is one exception, which is that if the indices follow the NCON convention, i.e. negative integers are used for uncontracted indices and positive integers for contracted indices. Then the contraction tree is built such that tensors that share the contraction index which is the lowest positive integer are contracted first. Relevant code can be found in <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/indexnotation/ncontree.jl"><code>src/indexnotation/ncontree.jl</code></a></p><p>When the <code>@tensoropt</code> macro was used, <code>optdata</code> is a dictionary associating a cost (either a number or a polynomial in some abstract scaling parameter) to every index, and this information is used to determine the (asymptotically) optimal contraction tree (in terms of number of floating point operations). The code for the latter is in <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/indexnotation/optimaltree.jl"><code>src/indexnotation/optimaltree.jl</code></a>, with the lightweight polynomial implementation in <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/indexnotation/poly.jl"><code>src/indexnotation/polynomial.jl</code></a>. Aside from a generic polynomial type <code>Poly</code>, the latter also contains a <code>Power</code> type which represents a single term of a polynomial (i.e. a scalar coefficient and an exponent). This type is closed under multiplication, and can be multiplied much more efficiently. Only under addition is a generic <code>Poly</code> returned.</p><h2 id="Building-blocks"><a class="docs-heading-anchor" href="#Building-blocks">Building blocks</a><a id="Building-blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Building-blocks" title="Permalink"></a></h2><p>The <code>@tensor</code> macro converts the index expression into a set of function calls corresponding to three primitive operations: addition, tracing and contraction. These operations are implemented for arbitrary strided arrays from Julia Base, i.e. <code>Array</code>s, views with ranges thereof, and certain reshape operations. This includes certain arrays that can only be determined to be strided on runtime, and does therefore not coincide with the type union <code>StridedArray</code> from Julia Base. In fact, the methods accept <code>AbstractArray</code> objects, but convert these to <code>(Unsafe)StridedView</code> objects from the package <a href="https://github.com/Jutho/Strided.jl">Strided.jl</a>, and we refer to this package for a more detailed discussion on which arrays are supported and why.</p><p>The primitive tensor operations are captured by the following mutating methods (note that these are not exported)</p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.add!" href="#TensorOperations.add!"><code>TensorOperations.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add!(α, A, conjA, β, C, indleft, indright)</code></pre><p>Implements <code>C = β*C+α*permute(op(A))</code> where <code>A</code> is permuted such that the left (right) indices of <code>C</code> correspond to the indices <code>indleft</code> (<code>indright</code>) of <code>A</code>, and <code>op</code> is <code>conj</code> if <code>conjA == :C</code> or the identity map if <code>conjA == :N</code> (default). Together, <code>(indleft..., indright...)</code> is a permutation of 1 to the number of indices (dimensions) of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/da466f7474d7d04a4f61cf94415c7b092772333c/src/implementation/stridedarray.jl#L43-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.trace!" href="#TensorOperations.trace!"><code>TensorOperations.trace!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trace!(α, A, conjA, β, C, indleft, indright, cind1, cind2)</code></pre><p>Implements <code>C = β*C+α*partialtrace(op(A))</code> where <code>A</code> is permuted and partially traced, such that the left (right) indices of <code>C</code> correspond to the indices <code>indleft</code> (<code>indright</code>) of <code>A</code>, and indices <code>cindA1</code> are contracted with indices <code>cindA2</code>. Furthermore, <code>op</code> is <code>conj</code> if <code>conjA == :C</code> or the identity map if <code>conjA=:N</code> (default). Together, <code>(indleft..., indright..., cind1, cind2)</code> is a permutation of 1 to the number of indices (dimensions) of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/da466f7474d7d04a4f61cf94415c7b092772333c/src/implementation/stridedarray.jl#L55-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.contract!" href="#TensorOperations.contract!"><code>TensorOperations.contract!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contract!(α, A, conjA, B, conjB, β, C, oindA, cindA, oindB, cindB, indleft, indright, syms = nothing)</code></pre><p>Implements <code>C = β*C+α*contract(opA(A),opB(B))</code> where <code>A</code> and <code>B</code> are contracted, such that the indices <code>cindA</code> of <code>A</code> are contracted with indices <code>cindB</code> of <code>B</code>. The open indices <code>oindA</code> of <code>A</code> and <code>oindB</code> of <code>B</code> are permuted such that <code>C</code> has left (right) indices corresponding to indices <code>indleft</code> (<code>indright</code>) out of <code>(oindA..., oindB...)</code>. The operation <code>opA</code> (<code>opB</code>) acts as <code>conj</code> if <code>conjA</code> (<code>conjB</code>) equal <code>:C</code> or as the identity map if <code>conjA</code> (<code>conjB</code>) equal <code>:N</code>. Together, <code>(oindA..., cindA...)</code> is a permutation of 1 to the number of indices of <code>A</code> and <code>(oindB..., cindB...)</code> is a permutation of 1 to the number of indices of <code>C</code>. Furthermore, <code>length(cindA) == length(cindB)</code>, <code>length(oindA)+length(oindB)</code> equals the number of indices of <code>C</code> and <code>(indleft..., indright...)</code> is a permutation of <code>1</code> ot the number of indices of <code>C</code>.</p><p>The final argument <code>syms</code> is optional and can be either <code>nothing</code>, or a tuple of three symbols, which are used to identify temporary objects in the cache to be used for permuting <code>A</code>, <code>B</code> and <code>C</code> so as to perform the contraction as a matrix multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/da466f7474d7d04a4f61cf94415c7b092772333c/src/implementation/stridedarray.jl#L69-L86">source</a></section></article><p>These are the central objects that should be overloaded by custom tensor types that would like to be used within the <code>@tensor</code> environment. They are also used by the function based methods discussed in the section <a href="../functions/#Functions">Functions</a>.</p><p>Furthermore, it is essential to be able to construct new tensor objects that are similar to existing ones, i.e. to place the result of the computation in case no output is specified. In order to reuse temporary objects stored in the global cache, this method also receives a candidate similar object, which it can return if it matches the requirements.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>TensorOperations.checked_similar_from_indices</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Note that the type of the cached object is not known to the compiler, as the cache stores objects as <code>Any</code>. Therefore, the function <code>checked_similar_from_indices</code> should try to restore the type information. By passing any object retrieved from the cache through this function, type stability within the <code>@tensor</code> macro can then still be guaranteed.</p><p>Finally, there is a particularly simple method <code>scalar</code> whose sole purpose is to extract the single entry of an object with zero indices, i.e. an instance of <code>AbstractArray{T,0}</code> in case of Julia Base arrays:</p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.scalar" href="#TensorOperations.scalar"><code>TensorOperations.scalar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scalar(C)</code></pre><p>Returns the single element of a tensor-like object with zero indices or dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/da466f7474d7d04a4f61cf94415c7b092772333c/src/implementation/stridedarray.jl#L36-L40">source</a></section></article><p>The implementation of all of these methods can be found in <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/implementation/stridedarray.jl"><code>src/implementation/stridedarray.jl</code></a>.</p><p>By implementing these five methods for other types that represent some kind of tensor or multidimensional object, they can be used in combination with the <code>@tensor</code> macro. In particular, we also provide basic support for contracting a <code>Diagonal</code> matrix with an arbitrary strided array in <a href="https://github.com/Jutho/TensorOperations.jl/blob/master/src/implementation/diagonal.jl"><code>src/implementation/diagonal.jl</code></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../cache/">« Cache for temporaries</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 13 April 2022 22:01">Wednesday 13 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
