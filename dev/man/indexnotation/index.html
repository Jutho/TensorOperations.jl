<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index notation with macros · TensorOperations.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="TensorOperations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorOperations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Index notation with macros</a><ul class="internal"><li><a class="tocitem" href="#The-@tensor-macro"><span>The <code>@tensor</code> macro</span></a></li><li><a class="tocitem" href="#Contraction-order-specification-and-optimisation"><span>Contraction order specification and optimisation</span></a></li><li><a class="tocitem" href="#Dynamical-tensor-network-contractions-with-ncon-and-@ncon"><span>Dynamical tensor network contractions with <code>ncon</code> and <code>@ncon</code></span></a></li><li><a class="tocitem" href="#Index-compatibility-and-checks"><span>Index compatibility and checks</span></a></li><li><a class="tocitem" href="#Backends,-multithreading-and-GPUs"><span>Backends, multithreading and GPUs</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../autodiff/">Automatic differentiation</a></li><li><a class="tocitem" href="../implementation/">Implementation</a></li></ul></li><li><a class="tocitem" href="../../index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Index notation with macros</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index notation with macros</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorOperations.jl/blob/master/docs/src/man/indexnotation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index-notation-with-macros"><a class="docs-heading-anchor" href="#Index-notation-with-macros">Index notation with macros</a><a id="Index-notation-with-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Index-notation-with-macros" title="Permalink"></a></h1><p>The main export and main functionality of TensorOperations.jl is the <code>@tensor</code> macro</p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.@tensor" href="#TensorOperations.@tensor"><code>TensorOperations.@tensor</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tensor(tensor_expr; kwargs...)
@tensor [kw_expr...] tensor_expr</code></pre><p>Specify one or more tensor operations using Einstein&#39;s index notation. Indices can be chosen to be arbitrary Julia variable names, or integers. When contracting several tensors together, this will be evaluated as pairwise contractions in left to right order, unless the so-called NCON style is used (positive integers for contracted indices and negative indices for open indices).</p><p>Additional keyword arguments may be passed to control the behavior of the parser:</p><ul><li><code>order</code>:    A list of contraction indices of the form <code>order=(...,)</code> which specify the order in which they will be contracted.</li><li><code>opt</code>:   Contraction order optimization, similar to <a href="#TensorOperations.@tensoropt"><code>@tensoropt</code></a>. Can be either a boolean or an <code>OptExpr</code>.</li><li><code>contractcheck</code>:   Boolean flag to enable runtime check for contractibility of indices with clearer error messages.</li><li><code>costcheck</code>:   Can be either <code>:warn</code> or <code>:cache</code> and adds runtime checks to compare the compile-time contraction order to the optimal order computed for the actual run time tensor costs.   If <code>costcheck == :warn</code>, warnings are printed for every sub-optimal contraction that is encountered.   If <code>costcheck == :cache</code>, only the most costly run of a particular sub-optimal contraction will be cached in <code>TensorOperations.costcache</code>.   In both cases, a suggestion for the <code>order</code> keyword argument is computed to switch to the optimal contraction order.</li><li><code>backend</code>:    Inserts an implementation backend as a final argument in the different tensor operation calls in the generated code.</li><li><code>allocator</code>:   Inserts an allocation strategy as a final argument in the tensor allocation calls in the generated code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/indexnotation/tensormacros.jl#L12-L39">source</a></section></article><p>The functionality and configurability of <code>@tensor</code> and some of its relatives is explained in detail on this page.</p><h2 id="The-@tensor-macro"><a class="docs-heading-anchor" href="#The-@tensor-macro">The <code>@tensor</code> macro</a><a id="The-@tensor-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@tensor-macro" title="Permalink"></a></h2><p>The prefered way to specify (a sequence of) tensor operations is by using the <code>@tensor</code> macro, which accepts an <a href="https://en.wikipedia.org/wiki/Abstract_index_notation">index notation</a> format, a.k.a. <a href="https://en.wikipedia.org/wiki/Einstein_notation">Einstein notation</a> (and in particular, Einstein&#39;s summation convention).</p><p>This can most easily be explained using a simple example:</p><pre><code class="language-julia hljs">using TensorOperations
α = randn()
A = randn(5, 5, 5, 5, 5, 5)
B = randn(5, 5, 5)
C = randn(5, 5, 5)
D = zeros(5, 5, 5)
@tensor begin
    D[a, b, c] = A[a, e, f, c, f, g] * B[g, b, e] + α * C[c, a, b]
    E[a, b, c] := A[a, e, f, c, f, g] * B[g, b, e] + α * C[c, a, b]
end</code></pre><p>The first important observation is the use of two different assignment operators within the body of the <code>@tensor</code> call. The regular assignment operator <code>=</code> stores the result of the tensor expression in the right hand side in an existing tensor <code>D</code>, whereas the &#39;definition&#39; operator <code>:=</code> results in a new tensor <code>E</code> with the correct properties to be created. Nonetheless, the contents of <code>D</code> and <code>E</code> will be equal.</p><p>Following Einstein&#39;s summation convention, that contents is computed in a number of steps involving the three primitive tensor operators. In this particular example, the first step involves tracing/contracting the 3rd and 5th index of array <code>A</code>, the result of which is stored in a temporary array which thus needs to be created. This resulting array will then be contracted with array <code>B</code> by contracting its 2nd index with the last index of <code>B</code> and its last index with the first index of <code>B</code>. The result is stored in <code>D</code> in the first line, or in a newly allocated array which will end up being <code>E</code> in the second line. Note that the index order of <code>D</code> and <code>E</code> is such that its first index corresponds to the first index of <code>A</code>, the second index corresponds to the second index of <code>B</code>, whereas the third index corresponds to the fourth index of <code>A</code>. Finally, the array <code>C</code> (scaled with <code>α</code>) is added to this result (in place), which requires a further index permutation.</p><p>The index pattern is analyzed at compile time and expanded to a set of calls to the basic tensor operations, i.e. <a href="../functions/#TensorOperations.tensoradd!"><code>tensoradd!</code></a>, <a href="../functions/#TensorOperations.tensortrace!"><code>tensortrace!</code></a> and <a href="../functions/#TensorOperations.tensorcontract!"><code>tensorcontract!</code></a>. Temporaries are created where necessary, as these building blocks operate pairwise on the input tensors. The generated code can easily be inspected</p><pre><code class="language-julia hljs">using TensorOperations
@macroexpand @tensor E[a, b, c] := A[a, e, f, c, f, g] * B[g, b, e] + α * C[c, a, b]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">quote
    var&quot;##T_E#309&quot; = TensorOperations.promote_add(TensorOperations.promote_contract(TensorOperations.scalartype(A), TensorOperations.scalartype(B)), Base.promote_op(*, TensorOperations.scalartype(C), TensorOperations.scalartype(α * VectorInterface.One())))
    var&quot;##T_##E_A#310#311&quot; = TensorOperations.scalartype(A)
    var&quot;##E_A#310&quot; = TensorOperations.tensoralloc_add(var&quot;##T_##E_A#310#311&quot;, ((1, 4), (2, 6)), A, :N, true)
    var&quot;##E_A#310&quot; = TensorOperations.tensortrace!(var&quot;##E_A#310&quot;, ((1, 4), (2, 6)), A, ((3,), (5,)), :N, VectorInterface.One(), VectorInterface.Zero())
    var&quot;##T_E#312&quot; = TensorOperations.promote_contract(TensorOperations.scalartype(var&quot;##E_A#310&quot;), TensorOperations.scalartype(B))
    E = TensorOperations.tensoralloc_contract(var&quot;##T_E#312&quot;, ((1, 3, 2), ()), var&quot;##E_A#310&quot;, ((1, 2), (3, 4)), :N, B, ((3, 1), (2,)), :N, false)
    E = TensorOperations.tensorcontract!(E, ((1, 3, 2), ()), var&quot;##E_A#310&quot;, ((1, 2), (3, 4)), :N, B, ((3, 1), (2,)), :N, VectorInterface.One(), VectorInterface.Zero())
    TensorOperations.tensorfree!(var&quot;##E_A#310&quot;)
    E
    E = TensorOperations.tensoradd!(E, ((2, 3, 1), ()), C, :N, α * VectorInterface.One(), VectorInterface.One())
end</code></pre><p>The different functions in which this tensor expression is decomposed are discussed in more detail in the <a href="../implementation/#Implementation">Implementation</a> section of this manual.</p><p>In this example, the tensor indices were labeled with arbitrary letters; also longer names could have been used. In fact, any proper Julia variable name constitutes a valid label. Note though that these labels are never interpreted as existing Julia variables. Within the <code>@tensor</code> macro they are converted into symbols and then used as dummy names, whose only role is to distinguish the different indices. Their specific value bears no meaning. They also do not appear in the generated code as illustrated above. This implies, in particular, that the specific tensor operations defined by the code inside the <code>@tensor</code> environment are completely specified at compile time. Various remarks regarding the index notation are in order.</p><ol><li><p>TensorOperations.jl only supports strict Einstein summation convention. This implies  that there are two types of indices. Either an index label appears once in every term of  the right hand side, and it also appears on the left hand side. We refer to the  corresponding indices as <em>open or free</em>. Alternatively, an index label appears exactly  twice within a given term on the right hand side. The corresponding indices are referred  to as <em>closed or contracted</em>, i.e. the pair of indices takes equal values and are summed  over their (equal) range. This is known as a contraction, either an outer contraction  (between two indices of two different tensors) or an inner contraction (a.k.a. trace,  between two indices of a single tensor). More liberal use of the index notation, such as  simultaneous summutation over three or more indices, or a open index appearing  simultaneously in different tensor factors, are not supported by TensorOperations.jl.</p></li><li><p>Aside from valid Julia identifiers, index labels can also be specified using literal  integer constants or using a combination of integers and symbols. Furthermore, it is  also allowed to use primes (i.e. Julia&#39;s <code>adjoint</code> operator) to denote different  indices, including using multiple subsequent primes. The following expression thus  computes the same result as the example above:</p><pre><code class="language-julia hljs">@tensor D[å&#39;&#39;, ß, clap&#39;] = A[å&#39;&#39;, 1, -3, clap&#39;, -3, 2] * B[2, ß, 1] + α * C[clap&#39;, å&#39;&#39;, ß]</code></pre></li><li><p>If only integers are used for specifying index labels, this can be used to control the  pairwise contraction order, by using the well-known NCON convention, where open indices  in the left hand side are labelled by negative integers <code>-1</code>, <code>-2</code>, <code>-3</code>, whereas  contraction indices are labelled with positive integers <code>1</code>, <code>2</code>, … Since the index  order of the left hand side is in that case clear from the right hand side expression,  the left hand side can be indexed with <code>[:]</code>, which is automatically replaced with all  negative integers appearing in the right hand side, in decreasing order. The value of  the labels for the contraction indices determines the pairwise contraction order. If  multiple tensors need to be contracted, a first temporary will be created consisting of  the contraction of the pair of tensors that share contraction index <code>1</code>, then the pair  of tensors that share contraction index <code>2</code> (if not contracted away in the first pair)  will be contracted, and so forth. The next subsection explains contraction order in more  detail and gives some useful examples, as the example above only includes a single pair  of tensors to be contracted.</p></li><li><p>Index labels always appear in square brackets <code>[ ... ]</code> but can be separated by either  commas, as in <code>D[a, b, c]</code>, (yielding a <code>:ref</code> expression) or by spaces, as in  <code>D[a b c]</code>, (yielding a <code>:typed_hcat</code> expression).</p><p>There is also the option to separate the indices into two groups using a semicolon. This  can be useful for tensor types which have two distinct set of indices, but has no effect  when using Julia <code>AbstractArray</code> objects. While in principle both spaces and commas can  be used within the two groups, e.g. as in <code>D[a, b; c]</code> or <code>D[a b; c]</code>, there are some  restrictions because of accepted Julia syntax. Both groups of indices should use the  same convention. If there is only a single index in the first group, the second group  should use spaces to constitute a valid expression. Finally, having no indices in the  first group is only possible by writing an empty tuple. The second group can then use  spaces, or also contain the indices as a tuple, i.e. both <code>D[(); a b c]</code> or <code>D[(); (a,  b, c)]</code>. Writing the two groups of indices within a tuple (which uses a comma as natural  separator), with both tuples seperated by a semicolon is always valid syntax,  irrespective of the number of indices in that group.</p></li><li><p>Index expressions <code>[...]</code> are only interpreted as index notation on the highest level.  For example, if you want to mulitply two matrices which are stored in a list, you can  write</p><pre><code class="language-julia hljs">@tensor result[i,j] := list[1][i,k] * list[2][k,j]</code></pre><p>However, if both are stored as a the slices of a 3-way array, you cannot write</p><pre><code class="language-julia hljs">@tensor result[i,j] := list[i,k,1] * list[k,j,2]</code></pre><p>Rather, you should use</p><pre><code class="language-julia hljs">@tensor result[i,j] := list[:,:,1][i,k] * list[:,:,2][k,j]</code></pre><p>or, if you want to avoid additional allocations</p><pre><code class="language-julia hljs">@tensor result[i,j] := view(list,:,:,1)[i,k] * view(list,:,:,2)[k,j]</code></pre></li></ol><p>Note, finally, that the <code>@tensor</code> specifier can be put in front of a single tensor expression, or in front of a <code>begin ... end</code> block to group and evaluate different expressions at once. Within an <code>@tensor begin ... end</code> block, the <code>@notensor</code> macro can be used to annotate indexing expressions that need to be interpreted literally. </p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.@notensor" href="#TensorOperations.@notensor"><code>TensorOperations.@notensor</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@notensor(block)</code></pre><p>Marks a block which should be ignored within an <code>@tensor</code> environment. Has no effect outside of <code>@tensor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/indexnotation/tensormacros.jl#L3-L7">source</a></section></article><p>As in illustration, note that the previous code examples about the matrix multiplication with matrices stored in a 3-way array can now also be written as</p><pre><code class="language-julia hljs">@tensor begin
    @notensor A = list[:,:,1]
    @notensor B = list[:,:,2]
    result[i,j] = A[i,k] * B[k,j]
end</code></pre><h2 id="Contraction-order-specification-and-optimisation"><a class="docs-heading-anchor" href="#Contraction-order-specification-and-optimisation">Contraction order specification and optimisation</a><a id="Contraction-order-specification-and-optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#Contraction-order-specification-and-optimisation" title="Permalink"></a></h2><p>A contraction of several (more than two) tensors, as in</p><pre><code class="language-julia hljs">@tensor D[a, d, j, i, g] := A[a, b, c, d, e] * B[b, e, f, g] * C[c, f, i, j]</code></pre><p>is known as a <em>tensor network</em> and is generically evaluated as a sequence of pairwise contractions. In the example above, this contraction is evaluated using Julia&#39;s default left to right order, i.e. as <code>(A[a, b, c, d, e] * B[b, e, f, g]) * C[c, f, i, j]</code>. There are however different strategies to modify this order.</p><ol><li><p>Explicit parenthesis can be used to group subnetworks within a tensor network that will  be evaluated first. Parentheses around subexpressions are always respected by the  <code>@tensor</code> macro.</p></li><li><p>As explained in the previous subsection, if one respects the  <a href="https://arxiv.org/abs/1402.0939">NCON</a> convention of specifying indices, i.e. positive  integers for the contracted indices and negative indices for the open indices, the  different factors will be reordered and so that the pairwise tensor contractions  contract over indices with smaller integer label first. For example,</p><pre><code class="language-julia hljs">@tensor D[:] := A[-1, 3, 1, -2, 2] * B[3, 2, 4, -5] * C[1, 4, -4, -3]</code></pre><p>will be evaluated as <code>(A[-1, 3, 1, -2, 2] * C[1, 4, -4, -3]) * B[3, 2, 4, -5]</code>.  Furthermore, in that case the indices of the output tensor (<code>D</code> in this case) do not  need to be specified (using <code>[:]</code> instead), and will be chosen as  <code>(-1, -2, -3, -4, -5)</code>. Note that if two tensors are contracted, all contraction indices  among them will be contracted, even if there are additional contraction indices whose  label is a higher positive number. For example,</p><pre><code class="language-julia hljs">@tensor D[:] := A[-1, 3, 2, -2, 1] * B[3, 1, 4, -5] * C[2, 4, -4, -3]</code></pre><p>amounts to the original left to right order, because <code>A</code> and <code>B</code> share the first  contraction index <code>1</code>. When <code>A</code> and <code>B</code> are contracted, also the contraction with label  <code>3</code> will be performed, even though contraction index with label <code>2</code> is not yet  &#39;processed&#39;.</p></li><li><p>A specific contraction order can be manually specified by supplying an <code>order</code> keyword  argument to the <code>@tensor</code> macro. The value is a tuple of the contraction indices in the  order that they should be dealt with, e.g. the default order could be changed to first  contract <code>A</code> with <code>C</code> using</p><pre><code class="language-julia hljs">@tensor order=(c, b, e, f) begin
    D[a, d, j, i, g] := A[a, b, c, d, e] * B[b, e, f, g] * C[c, f, i, j]
end</code></pre><p>Here, the same comment as in the NCON style applies; once two tensors are contracted  because they share an index label which is next in the <code>order</code> list, all other indices  with shared label among them will be contracted, irrespective of their order.</p></li></ol><p>In the case of more complex tensor networks, the optimal contraction order cannot always easily be guessed or determined on plain sight. It is then useful to be able to optimize the contraction order automatically, given a model for the complexity of contracting the different tensors in a particular order. This functionality is provided where the cost function being minimized models the computational complexity by counting the number of scalar multiplications. This minimisation problem is solved using the algorithm that was described in <a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.90.033315">Physical Review E 90, 033315 (2014)</a>. For a given tensor networ contraction, this algorithm is ran once at compile time, while lowering the tensor espression, and the outcome will be hard coded in the expression resulting from the macro expansion. While the computational complexity of this optimisation algorithm scales itself exponentially in the number of tensors involved in the network, it should still be acceptibly fast (milliseconds up to a few seconds at most) for tensor network contractions with up to around 30 tensors. Information of the optimization process can be obtained during compilation by using the alternative macro <code>@tensoropt_verbose</code>.</p><p>As the cost is determined at compile time, it is not using actual tensor properties (e.g. <code>size(A, i)</code> in the case of arrays) in the cost model, and the cost or extent associated with every index can be specified in various ways, either using integers or floating point numbers or some arbitrary univariate polynomial of an abstract variable, e.g. <code>χ</code>. In the latter case, the optimization assumes the asymptotic limit of large <code>χ</code>.</p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.@tensoropt" href="#TensorOperations.@tensoropt"><code>TensorOperations.@tensoropt</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tensoropt(optex, block)
@tensoropt(block)</code></pre><p>Specify one or more tensor operations using Einstein&#39;s index notation. Indices can be chosen to be arbitrary Julia variable names, or integers. When contracting several tensors together, the macro will determine (at compile time) the optimal contraction order depending on the cost associated to the individual indices. If no <code>optex</code> is provided, all indices are assumed to have an abstract scaling <code>χ</code> which is optimized in the asympotic limit of large <code>χ</code>.</p><p>The cost can be specified in the following ways:</p><pre><code class="language-julia hljs"># cost χ for all indices (a, b, c, d, e, f)
@tensoropt D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]

# asymptotic cost χ for indices (a, b, c, e), other indices (d, f) have cost 1
@tensoropt (a, b, c, e) C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]

# cost 1 for indices (a, b, c, e); other indices (d, f) have asymptotic cost χ
@tensoropt !(a, b, c, e) C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]

# cost as specified for listed indices, unlisted indices have cost 1 (any symbol for χ can be used)
@tensoropt (a =&gt; χ, b =&gt; χ^2, c =&gt; 2 * χ, e =&gt; 5) begin
    C[a, b, c, d] := A[a, e, c, f, h] * B[f, g, e, b] * C[g, d, h]
end</code></pre><p>Note that <code>@tensoropt</code> will optimize any tensor contraction sequence it encounters in the (block of) expressions. It will however not break apart expressions that have been explicitly grouped with parenthesis, i.e. in</p><pre><code class="language-julia hljs">@tensoropt C[a, b, c, d] := A[a, e, c, f, h] * (B[f, g, e, b] * C[g, d, h])</code></pre><p>it will always contract <code>B</code> and <code>C</code> first. For a single tensor contraction sequence, the optimal contraction order and associated (asymptotic) cost can be obtained using <code>@optimalcontractiontree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/indexnotation/tensormacros.jl#L112-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.@tensoropt_verbose" href="#TensorOperations.@tensoropt_verbose"><code>TensorOperations.@tensoropt_verbose</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tensoropt_verbose(optex, block)
@tensoropt_verbose(block)</code></pre><p>Similar to <a href="#TensorOperations.@tensoropt"><code>@tensoropt</code></a>, but prints information details regarding the optimization process to the standard output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/indexnotation/tensormacros.jl#L166-L171">source</a></section></article><p>As an final remark, the optimization can also be accessed directly from <code>@tensor</code> by specifying the additional keyword argument <code>opt=true</code>, which will then use the default cost model, or <code>opt=optex</code> to further specify the costs.</p><pre><code class="language-julia hljs"># cost χ for all indices (a, b, c, d, e, f)
@tensor opt=true D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]

# cost χ for indices (a, b, c, e), other indices (d, f) have cost 1
@tensor opt=(a, b, c, e) D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]

# cost 1 for indices (a, b, c, e), other indices (d, f) have cost χ
@tensor opt=!(a, b, c, e) D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]

# cost as specified for listed indices, unlisted indices have cost 1 (any symbol for χ can be used)
@tensor opt=(a =&gt; χ, b =&gt; χ^2, c =&gt; 2 * χ, e =&gt; 5) begin
    D[a, b, c, d] := A[a, e, c, f] * B[g, d, e] * C[g, f, b]
end
</code></pre><h2 id="Dynamical-tensor-network-contractions-with-ncon-and-@ncon"><a class="docs-heading-anchor" href="#Dynamical-tensor-network-contractions-with-ncon-and-@ncon">Dynamical tensor network contractions with <code>ncon</code> and <code>@ncon</code></a><a id="Dynamical-tensor-network-contractions-with-ncon-and-@ncon-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-tensor-network-contractions-with-ncon-and-@ncon" title="Permalink"></a></h2><p>Tensor network practicioners are probably more familiar with the network contractor function <a href="#TensorOperations.ncon"><code>ncon</code></a> to perform a tensor network contraction, as e.g. described in <a href="https://arxiv.org/abs/1402.0939">NCON</a>. In particular, a graphical application <a href="https://www.tensortrace.com">TensorTrace</a> was recently introduced to facilitate the generation of such <code>ncon</code> calls. TensorOperations.jl provides compatibility with this interface by also exposing an <code>ncon</code> function with the same basic syntax</p><pre><code class="language-julia hljs">ncon(list_of_tensor_objects, list_of_index_lists)</code></pre><p>e.g. the example of above is equivalent to</p><pre><code class="language-julia hljs">@tensor D[:] := A[-1, 3, 1, -2, 2] * B[3, 2, 4, -5] * C[1, 4, -4, -3]
D ≈ ncon((A, B, C), ([-1, 3, 1, -2, 2], [3, 2, 4, -5], [1, 4, -4, -3]))</code></pre><p>where the lists of tensor objects and of index lists can be given as a vector or a tuple. The <code>ncon</code> function necessarily needs to analyze the contraction pattern at runtime, but this can be an advantage, in cases where the contraction is determined by runtime information and thus not known at compile time. A downside from this, besides the fact that this can result in some overhead (though this is typically negligable for anything but very small tensor contractions), is that <code>ncon</code> is type-unstable, i.e. its return type cannot be inferred by the Julia compiler.</p><p>The full call syntax of the <code>ncon</code> method exposed by TensorOperations.jl is</p><pre><code class="language-julia hljs">ncon(tensorlist, indexlist, [conjlist]; order=..., output=...)</code></pre><p>where the first two arguments are those of above. Let us first discuss the keyword arguments. The keyword argument <code>order</code> can be used to change the contraction order, i.e. by specifying which contraction indices need to be processed first, rather than the strictly increasing order <code>[1, 2, ...]</code>, as discussed in the previous subsection. The keyword argument <code>output</code> can be used to specify the order of the output indices, when it is different from the default <code>[-1, -2, ...]</code>.</p><p>The optional positional argument <code>conjlist</code> is a list of <code>Bool</code> variables that indicate whether the corresponding tensor needs to be conjugated in the contraction. So while</p><pre><code class="language-julia hljs">ncon([A, conj(B), C], [[-1, 3, 1, -2, 2], [3, 2, 4, -5], [1, 4, -4, -3]]) ≈
ncon([A, B, C], [[-1, 3, 1, -2, 2], [3, 2, 4, -5], [1, 4, -4, -3]], [false, true, false])</code></pre><p>the latter has the advantage that conjugating <code>B</code> is not an extra step (which creates an additional temporary requiring allocations), but is performed at the same time when it is contracted.</p><p>As an alternative solution to the optional positional arguments, there is also an <code>@ncon</code> macro. It is just a simple wrapper over an <code>ncon</code> call and thus does not analyze the indices at compile time, so that they can be fully dynamical. However, it will transform</p><pre><code class="language-julia hljs">@ncon([A, conj(B), C], indexlist; order=..., output=...)</code></pre><p>into</p><pre><code class="language-julia hljs">ncon(Any[A, B, C], indexlist, [false, true, false]; order=..., output=...)</code></pre><p>so as to get the advantages of just-in-time conjugation (pun intended) using the familiar looking <code>ncon</code> syntax.</p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.ncon" href="#TensorOperations.ncon"><code>TensorOperations.ncon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ncon(tensorlist, indexlist, [conjlist, sym]; order = ..., output = ...)</code></pre><p>Contract the tensors in <code>tensorlist</code> (of type <code>Vector</code> or <code>Tuple</code>) according to the network as specified by <code>indexlist</code>. Here, <code>indexlist</code> is a list (i.e. a <code>Vector</code> or <code>Tuple</code>) with the same length as <code>tensorlist</code> whose entries are themselves lists (preferably <code>Vector{Int}</code>) where every integer entry provides a label for corresponding index/dimension of the corresponding tensor in <code>tensorlist</code>. Positive integers are used to label indices that need to be contracted, and such thus appear in two different entries within <code>indexlist</code>, whereas negative integers are used to label indices of the output tensor, and should appear only once.</p><p>Optional arguments in another list with the same length, <code>conjlist</code>, whose entries are of type <code>Bool</code> and indicate whether the corresponding tensor object should be conjugated (<code>true</code>) or not (<code>false</code>). The default is <code>false</code> for all entries.</p><p>By default, contractions are performed in the order such that the indices being contracted over are labelled by increasing integers, i.e. first the contraction corresponding to label <code>1</code> is performed. The output tensor had an index order corresponding to decreasing (negative, so increasing in absolute value) index labels. The keyword arguments <code>order</code> and <code>output</code> allow to change these defaults.</p><p>See also the macro version <a href="#TensorOperations.@ncon"><code>@ncon</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/implementation/ncon.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.@ncon" href="#TensorOperations.@ncon"><code>TensorOperations.@ncon</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ncon(tensorlist, indexlist; order = ..., output = ...)</code></pre><p>Contract the tensors in <code>tensorlist</code> (of type <code>Vector</code> or <code>Tuple</code>) according to the network as specified by <code>indexlist</code>. Here, <code>indexlist</code> is a list (i.e. a <code>Vector</code> or <code>Tuple</code>) with the same length as <code>tensorlist</code> whose entries are themselves lists (preferably <code>Vector{Int}</code>) where every integer entry provides a label for corresponding index/dimension of the corresponding tensor in <code>tensorlist</code>. Positive integers are used to label indices that need to be contracted, and such thus appear in two different entries within <code>indexlist</code>, whereas negative integers are used to label indices of the output tensor, and should appear only once.</p><p>By default, contractions are performed in the order such that the indices being contracted over are labelled by increasing integers, i.e. first the contraction corresponding to label <code>1</code> is performed. The output tensor had an index order corresponding to decreasing (negative, so increasing in absolute value) index labels. The keyword arguments <code>order</code> and <code>output</code> allow to change these defaults.</p><p>The advantage of the macro <code>@ncon</code> over the function call <code>ncon</code> is that, if <code>tensorlist</code> is not just some variable but an actual list (as a tuple with parentheses or a vector with square brackets) at the call site, the <code>@ncon</code> macro will scan for conjugation calls, e.g. <code>conj(A)</code>, and replace this with just <code>A</code> but build a matching list of conjugation flags to be specified to <code>ncon</code>. This makes it more convenient to specify tensor conjugation, without paying the cost of actively performing the conjugation beforehand.</p><p>See also the function <a href="#TensorOperations.ncon"><code>ncon</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/indexnotation/tensormacros.jl#L208-L234">source</a></section></article><h2 id="Index-compatibility-and-checks"><a class="docs-heading-anchor" href="#Index-compatibility-and-checks">Index compatibility and checks</a><a id="Index-compatibility-and-checks-1"></a><a class="docs-heading-anchor-permalink" href="#Index-compatibility-and-checks" title="Permalink"></a></h2><p>Indices with the same label, either open indices on the two sides of the equation, or contracted indices, need to be compatible. For <code>AbstractArray</code> objects, this means they must have the same size. Other tensor types might have more complicated structure associated with their indices, and requires matching between those. The function <a href="../interface/#TensorOperations.checkcontractible"><code>checkcontractible</code></a> is part of the interface that can be used to control when tensors can be contracted with each other along specific indices.</p><p>If indices do not match, the contraction will spawn an error. However, this can be an error deep within the implementation, at which point the error message will provide little information as to which specific tensors and which indices are producing the mismatch. When debugging, it might be useful to add the keyword argument <code>contractcheck = true</code> to the <code>@tensor</code> macro. Explicit checks using <code>checkcontractible</code> are then enabled that are run before any tensor operation is performed. When a mismatch is detected, these checks still have access to the label information and spawn a more informative error message.</p><p>A different type of check is the <code>costcheck</code> keyword argument, which can be given the values <code>:warn</code> or <code>:cache</code>. With either of both values for this keyword argument, additional checks are inserted that compare the contraction order of any tensor contraction of three or more factors against the optimal order based on the current tensor size. More generally, the function <a href="../interface/#TensorOperations.tensorcost"><code>tensorcost</code></a> is part of the interface and associated a cost value with every index of a tensor, which is then used in the cost model. With <code>costcheck=:warn</code>, a warning will be spawned for every tensor network where the actual contraction order (even when optimized using abstract costs) does not match with the ideal contraction order given the current <code>tensorcost</code> values. With <code>costcheck = :cache</code>, the tensor networks with non-optimal contraction order are stored in a global package variable <code>TensorOperations.costcache</code>. However, when a tensor network is evaluated several times with different tensor sizes or tensor costs, only the evaluation giving rise to the largest total contraction cost for that network will appear in the cache (provided the actual contraction order deviates from the optimal order in that largest case).</p><h2 id="Backends,-multithreading-and-GPUs"><a class="docs-heading-anchor" href="#Backends,-multithreading-and-GPUs">Backends, multithreading and GPUs</a><a id="Backends,-multithreading-and-GPUs-1"></a><a class="docs-heading-anchor-permalink" href="#Backends,-multithreading-and-GPUs" title="Permalink"></a></h2><p>Every index expression will be evaluated as a sequence of elementary tensor operations, i.e. permuted additions, partial traces and contractions, which are implemented for strided arrays as discussed in <a href="../../#Package-features">Package features</a>. In particular, these implementations rely on <a href="https://github.com/Jutho/Strided.jl">Strided.jl</a>, and we refer to this package for a full specification of which arrays are supported. As a rule of thumb, this primarily includes <code>Array</code>s from Julia base, as well as <code>view</code>s thereof if sliced with a combination of <code>Integer</code>s and <code>Range</code>s. Special types such as <code>Adjoint</code> and <code>Transpose</code> from Base are also supported. For permuted addition and partial traces, native Julia implementations are used which could benefit from multithreading if <code>JULIA_NUM_THREADS&gt;1</code>.</p><p>The binary contraction is performed by first permuting the two input tensors into a form such that the contraction becomes equivalent to one matrix multiplication on the whole data, followed by a final permutation to bring the indices of the output tensor into the desired order. This approach allows to use the highly efficient matrix multiplication kernel (<code>gemm</code>) from BLAS, which is multithreaded by default. There is also a native contraction implementation that is used for e.g. arrays with an <code>eltype</code> that is not <code>&lt;:LinearAlgebra.BlasFloat</code>. It performs the contraction directly without the additional permutations, but still in a cache-friendly and multithreaded way (again relying on <code>JULIA_NUM_THREADS &gt; 1</code>). This implementation can also be used for <code>BlasFloat</code> types (but will typically be slower), and the use of BLAS can be controlled by explicitly switching the backend between <code>StridedBLAS</code> and <code>StridedNative</code> using the <code>backend</code> keyword to <a href="#TensorOperations.@tensor"><code>@tensor</code></a>. Similarly, different allocation strategies, when available, can be selected using the <code>allocator</code> keyword of <a href="#TensorOperations.@tensor"><code>@tensor</code></a>.</p><p>The primitive tensor operations are also implemented for <code>CuArray</code> objects of the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> library. This implementation is essentially a simple wrapper over the cuTENSOR library of NVidia, and will only be loaded when the <code>cuTENSOR.jl</code> package is loaded. The <code>@tensor</code> macro will then automatically work for operations between GPU arrays.</p><p>Mixed operations between host arrays (e.g. <code>Array</code>) and device arrays (e.g. <code>CuArray</code>) will fail. However, if one wants to harness the computing power of the GPU to perform all tensor operations, there is a dedicated macro <code>@cutensor</code>. This will transfer all host arrays to the GPU before performing the requested operations. If the output is an existing host array, the result will be copied back. If a new result array is created (i.e. using <code>:=</code>), it will remain on the GPU device and it is up to the user to transfer it back. Arrays are transfered to the GPU just before they are first used, and in a complicated tensor expression, this might have the benefit that transer of the later arrays overlaps with computation of earlier operations.</p><article class="docstring"><header><a class="docstring-binding" id="TensorOperations.@cutensor" href="#TensorOperations.@cutensor"><code>TensorOperations.@cutensor</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@cutensor tensor_expr</code></pre><p>Use the GPU to perform all tensor operations, through the use of the cuTENSOR library. This will transfer all arrays to the GPU before performing the requested operations. If the output is an existing host array, the result will be transferred back. If a new array is created (i.e. using <code>:=</code>), it will remain on the GPU device and it is up to the user to transfer it back. This macro is equivalent to <code>@tensor backend=cuTENSOR allocator=cuTENSOR tensor_expr</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This macro requires the cuTENSOR library to be installed and loaded. This can be achieved by running <code>using cuTENSOR</code> or <code>import cuTENSOR</code> before using the macro.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Jutho/TensorOperations.jl/blob/60a8722142dcb9f081d9b0017790afd7bec233b6/src/indexnotation/tensormacros.jl#L285-L298">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../functions/">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 September 2023 21:59">Thursday 14 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
