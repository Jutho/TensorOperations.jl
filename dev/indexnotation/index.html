<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index notation with macros · TensorOperations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorOperations.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">TensorOperations.jl</a></li><li class="is-active"><a class="tocitem" href>Index notation with macros</a><ul class="internal"><li><a class="tocitem" href="#The-@tensor-macro"><span>The <code>@tensor</code> macro</span></a></li><li><a class="tocitem" href="#Contraction-order-and-@tensoropt-macro"><span>Contraction order and <code>@tensoropt</code> macro</span></a></li><li><a class="tocitem" href="#Dynamical-tensor-network-contractions-with-ncon-and-@ncon"><span>Dynamical tensor network contractions with <code>ncon</code> and <code>@ncon</code></span></a></li><li><a class="tocitem" href="#Multithreading-and-GPU-evaluation-of-tensor-contractions-with-@cutensor"><span>Multithreading and GPU evaluation of tensor contractions with <code>@cutensor</code></span></a></li></ul></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../cache/">Cache for temporaries</a></li><li><a class="tocitem" href="../implementation/">Implementation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Home</a></li><li class="is-active"><a href>Index notation with macros</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index notation with macros</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorOperations.jl/blob/master/docs/src/indexnotation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index-notation-with-macros"><a class="docs-heading-anchor" href="#Index-notation-with-macros">Index notation with macros</a><a id="Index-notation-with-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Index-notation-with-macros" title="Permalink"></a></h1><h2 id="The-@tensor-macro"><a class="docs-heading-anchor" href="#The-@tensor-macro">The <code>@tensor</code> macro</a><a id="The-@tensor-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-@tensor-macro" title="Permalink"></a></h2><p>The prefered way to specify (a sequence of) tensor operations is by using the <code>@tensor</code> macro, which accepts an <a href="https://en.wikipedia.org/wiki/Abstract_index_notation">index notation</a> format, a.k.a. <a href="https://en.wikipedia.org/wiki/Einstein_notation">Einstein notation</a> (and in particular, Einstein&#39;s summation convention).</p><p>This can most easily be explained using a simple example:</p><pre><code class="language-julia">using TensorOperations
α=randn()
A=randn(5,5,5,5,5,5)
B=randn(5,5,5)
C=randn(5,5,5)
D=zeros(5,5,5)
@tensor begin
    D[a,b,c] = A[a,e,f,c,f,g]*B[g,b,e] + α*C[c,a,b]
    E[a,b,c] := A[a,e,f,c,f,g]*B[g,b,e] + α*C[c,a,b]
end</code></pre><p>In the second to last line, the result of the operation will be stored in the preallocated array <code>D</code>, whereas the last line uses a different assignment operator <code>:=</code> in order to define a new array <code>E</code> of the correct size. The contents of <code>D</code> and <code>E</code> will be equal.</p><p>Following Einstein&#39;s summation convention, the result is computed by first tracing/ contracting the 3rd and 5th index of array <code>A</code>. The resulting array will then be contracted with array <code>B</code> by contracting its 2nd index with the last index of <code>B</code> and its last index with the first index of <code>B</code>. The resulting array has three remaining indices, which correspond to the indices <code>a</code> and <code>c</code> of array <code>A</code> and index <code>b</code> of array <code>B</code> (in that order). To this, the array <code>C</code> (scaled with <code>α</code>) is added, where its first two indices will be permuted to fit with the order <code>a,c,b</code>. The result will then be stored in array <code>D</code>, which requires a second permutation to bring the indices in the requested order <code>a,b,c</code>.</p><p>In this example, the labels were specified by arbitrary letters or even longer names. Any valid variable name is valid as a label. Note though that these labels are never interpreted as existing Julia variables, but rather are converted into symbols by the <code>@tensor</code> macro. This means, in particular, that the specific tensor operations defined by the code inside the <code>@tensor</code> environment are completely specified at compile time. Alternatively, one can also choose to specify the labels using literal integer constants, such that also the following code specifies the same operation as above. Finally, it is also allowed to use primes (i.e. Julia&#39;s <code>adjoint</code> operator) to denote different indices, including using multiple subsequent primes.</p><pre><code class="language-julia">@tensor D[å&#39;&#39;,ß,c&#39;] = A[å&#39;&#39;,1,-3,c&#39;,-3,2]*B[2,ß,1] + α*C[c&#39;,å&#39;&#39;,ß]</code></pre><p>The index pattern is analyzed at compile time and expanded to a set of calls to the basic tensor operations, i.e. <a href="../implementation/#TensorOperations.add!"><code>TensorOperations.add!</code></a>, <a href="../implementation/#TensorOperations.trace!"><code>TensorOperations.trace!</code></a> and <a href="../implementation/#TensorOperations.contract!"><code>TensorOperations.contract!</code></a>. Temporaries are created where necessary, but will by default be saved to a global cache, so that they can be reused upon a next iteration or next call to the function in which the <code>@tensor</code> call is used. When experimenting in the REPL where every tensor expression is only used a single time, it might be better to use <a href="../cache/#TensorOperations.disable_cache"><code>TensorOperations.disable_cache</code></a>, though no real harm comes from using the cache (except higher memory usage). By default, the cache is allowed to take up to the minimum of either one gigabyte or 25% of the total machine memory, though this is fully configurable. We refer to the section on <a href="../cache/#Cache-for-temporaries">Cache for temporaries</a> for further details.</p><p>Note that the <code>@tensor</code> specifier can be put in front of a full block of code, or even in front of a function definition, if index expressions are prevalent throughout this block. If a certain part of the code is nonetheless to be interpreted literally and should not be transformed by the <code>@tensor</code> macro, it can be annotated using <code>@notensor</code>, e.g.</p><pre><code class="language-julia">@tensor function f(args...)
    some_tensor_expr
    some_more_tensor_exprs
    @notensor begin
        some_literal_indexing_expression
    end
    ...
end</code></pre><p>Note that <code>@notensor</code> annotations are only needed for indexing expressions which need to be interpreted literally.</p><h2 id="Contraction-order-and-@tensoropt-macro"><a class="docs-heading-anchor" href="#Contraction-order-and-@tensoropt-macro">Contraction order and <code>@tensoropt</code> macro</a><a id="Contraction-order-and-@tensoropt-macro-1"></a><a class="docs-heading-anchor-permalink" href="#Contraction-order-and-@tensoropt-macro" title="Permalink"></a></h2><p>A contraction of several tensors <code>A[a,b,c,d,e]*B[b,e,f,g]*C[c,f,i,j]*...</code> is generically evaluted as a sequence of pairwise contractions, using Julia&#39;s default left to right order, i.e. as <code>( (A[a,b,c,d,e] * B[b,e,f,g]) * C[c,f,i,j]) * ...)</code>. Explicit parenthesis can be used to modify this order. Alternatively, if one respects the so-called <a href="https://arxiv.org/abs/1402.0939">NCON</a> style of specifying indices, i.e. positive integers for the contracted indices and negative indices for the open indices, the different factors will be reordered and so that the pairwise tensor contractions contract over indices with smaller integer label first. For example,</p><pre><code class="language-julia">@tensor D[:] := A[-1,3,1,-2,2]*B[3,2,4,-5]*C[1,4,-4,-3]</code></pre><p>will be evaluated as <code>(A[-1,3,1,-2,2]*C[1,4,-4,-3])*B[3,2,4,-5]</code>. Furthermore, in that case the indices of the output tensor (<code>D</code> in this case) do not need to be specified (using <code>[:]</code> instead), and will be chosen as <code>(-1,-2,-3,-4,-5)</code>. Any other index order for the output tensor is of course still possible by just explicitly specifying it.</p><p>A final way to enforce a specific order is by giving the <code>@tensor</code> macro a second argument of the form <code>order=(list of indices)</code>, e.g.</p><pre><code class="language-julia">@tensor D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b] order=(f,e,g)</code></pre><p>This will now first perform the contraction corresponding to the index labeled <code>f</code>, i.e. the contraction between <code>A</code> and <code>C</code>. Then, the contraction corresponding to index labeled <code>e</code> will be performed, which is between <code>B</code> and the result of contracting <code>A</code> and <code>C</code>. If these objects share other contraction indices, in this case <code>g</code>, that contraction will be performed simultaneously, irrespective of its position in the list.</p><p>Furthermore, there is a <code>@tensoropt</code> macro which will optimize the contraction order to minimize the total number of multiplications (cost model might change or become configurable in the future). The optimal contraction order will be determined at compile time and will be hard coded in the expression resulting from the macro expansion. The cost/size of the different indices can be specified in various ways, and can be integers or some arbitrary polynomial of an abstract variable, e.g. <code>χ</code>. In the latter case, the optimization assumes the assymptotic limit of large <code>χ</code>.</p><pre><code class="language-julia">@tensoropt D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost χ for all indices (a,b,c,d,e,f)
@tensoropt (a,b,c,e) D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost χ for indices a,b,c,e, other indices (d,f) have cost 1
@tensoropt !(a,b,c,e) D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost 1 for indices a,b,c,e, other indices (d,f) have cost χ
@tensoropt (a=&gt;χ,b=&gt;χ^2,c=&gt;2*χ,e=&gt;5) D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]
# cost as specified for listed indices, unlisted indices have cost 1 (any symbol for χ can be used)</code></pre><p>Because of the compile time optimization process, the optimization cannot use run-time information such as the actual sizes of the tensors involved. If these sizes are fixed, they should be hardcoded by specifying the cost in one of the ways as above. The optimization algorithm was described in <a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.90.033315">Physical Review E 90, 033315 (2014)</a> and has a cost that scales exponentially in the number of tensors involved. For reasonably sized tensor network contractions with up to around 30 tensors, this should still be sufficiently fast (at most a few seconds) to be performed once at compile time, i.e. when the contraction is first invoked. Information of the optimization process can be obtained during compilation by using the alternative macro <code>@tensoropt_verbose</code>.</p><p>The optimal contraction tree as well as the associated cost can be obtained by</p><pre><code class="language-julia">@optimalcontractiontree D[a,b,c,d] := A[a,e,c,f]*B[g,d,e]*C[g,f,b]</code></pre><p>where the cost of the indices can be specified in the same various ways as for <code>@tensoropt</code>. In this case, no contraction is performed and the tensors involved do not need to exist.</p><h2 id="Dynamical-tensor-network-contractions-with-ncon-and-@ncon"><a class="docs-heading-anchor" href="#Dynamical-tensor-network-contractions-with-ncon-and-@ncon">Dynamical tensor network contractions with <code>ncon</code> and <code>@ncon</code></a><a id="Dynamical-tensor-network-contractions-with-ncon-and-@ncon-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-tensor-network-contractions-with-ncon-and-@ncon" title="Permalink"></a></h2><p>Tensor network practicioners are probably more familiar with the network contractor function <code>ncon</code> to perform a tensor network contraction, as e.g. described in <a href="https://arxiv.org/abs/1402.0939">NCON</a>. In particular, a graphical application <a href="https://www.tensortrace.com">TensorTrace</a> was recently introduced to facilitate the generation of such <code>ncon</code> calls. TensorOperations.jl now provides compatibility with this interface by also exposing an <code>ncon</code> function with the same basic syntax</p><pre><code class="language-julia">ncon(list_of_tensor_objects, list_of_index_lists)</code></pre><p>e.g. the example of above is equivalent to</p><pre><code class="language-julia">@tensor D[:] := A[-1,3,1,-2,2]*B[3,2,4,-5]*C[1,4,-4,-3]
D ≈ ncon((A,B,C),([-1,3,1,-2,2], [3,2,4,-5], [1,4,-4,-3]))</code></pre><p>where the lists of tensor objects and of index lists can be given as a vector or a tuple. The <code>ncon</code> function necessarily needs to analyze the contraction pattern at runtime, but this can be an advantage, in case where the contraction is determined by runtime information and thus not known at compile time. A downside from this, besides the fact that this can result in some overhead (though that is typical negligable for anything but very small tensor contractions), is that <code>ncon</code> is type-unstable, i.e. its return type cannot be inferred by the Julia compiler.</p><p>The full call syntax of the <code>ncon</code> method exposed by TensorOperations.jl is</p><pre><code class="language-julia">ncon(tensorlist, indexlist, [conjlist, sym]; order = ..., output = ...)</code></pre><p>where the first two arguments are those of above. Let us first discuss the keyword arguments. The keyword argument <code>order</code> can be used to change the contraction order, i.e. by specifying which contraction indices need to be processed first, rather than the strictly increasing order <code>[1,2,...]</code>. The keyword argument <code>output</code> can be used to specify the order of the output indices, when it is different from the default <code>[-1, -2, ...]</code>.</p><p>The optional positional argument <code>conjlist</code> is a list of <code>Bool</code> variables that indicate whether the corresponding tensor needs to be conjugated in the contraction. So while</p><pre><code class="language-julia">ncon([A,conj(B),C], [[-1,3,1,-2,2], [3,2,4,-5], [1,4,-4,-3]]) ≈
    ncon([A,B,C], [[-1,3,1,-2,2], [3,2,4,-5], [1,4,-4,-3]], [false, true, false])</code></pre><p>the latter has the advantage that conjugating <code>B</code> is not an extra step (which creates an additional temporary), but is performed at the same time when it is contracted. The fourth positional argument <code>sym</code>, also optional, can be a constant unique symbol that enables <code>ncon</code> to hook into the global cache structure for storing and recycling temporaries. When it is not specified, the cache cannot be used in any deterministically meaningful way.</p><p>As an alternative solution to the optional positional arguments, there is also an <code>@ncon</code> macro. It is just a simple wrapper over an <code>ncon</code> call and thus does not analyze the indices at compile time, so that they can be fully dynamical. However, it will transform</p><pre><code class="language-julia">@ncon([A, conj(B), C], indexlist; order = ..., output = ...)</code></pre><p>into</p><pre><code class="language-julia">ncon(Any[A, B, C], indexlist, [false, true, false], some_unique_sym, order = ..., output = ...)</code></pre><p>so as to get the advantages of cache for temporaries and just-in-time conjugation (pun intended) using the familiar looking <code>ncon</code> syntax.</p><p>As a proof of principle, let us study the following method for computing the environment to the <code>W</code> isometry in a MERA, as taken from <a href="https://www.tensors.net/mera">Tensors.net</a>, implemented in three different ways:</p><pre><code class="language-julia">function IsoEnvW1(hamAB,hamBA,rhoBA,rhoAB,w,v,u)
    indList1 = Any[[7,8,-1,9],[4,3,-3,2],[7,5,4],[9,10,-2,11],[8,10,5,6],[1,11,2],[1,6,3]]
    indList2 = Any[[1,2,3,4],[10,7,-3,6],[-1,11,10],[3,4,-2,8],[1,2,11,9],[5,8,6],[5,9,7]]
    indList3 = Any[[5,7,3,1],[10,9,-3,8],[-1,11,10],[4,3,-2,2],[4,5,11,6],[1,2,8],[7,6,9]]
    indList4 = Any[[3,7,2,-1],[5,6,4,-3],[2,1,4],[3,1,5],[7,-2,6]]
    wEnv = ncon(Any[hamAB,rhoBA,conj(w),u,conj(u),v,conj(v)],indList1) +
   			ncon(Any[hamBA,rhoBA,conj(w),u,conj(u),v,conj(v)],indList2) +
   			ncon(Any[hamAB,rhoBA,conj(w),u,conj(u),v,conj(v)],indList3) +
   			ncon(Any[hamBA,rhoAB,v,conj(v),conj(w)],indList4);
    return wEnv
end

function IsoEnvW2(hamAB,hamBA,rhoBA,rhoAB,w,v,u)
    indList1 = Any[[7,8,-1,9],[4,3,-3,2],[7,5,4],[9,10,-2,11],[8,10,5,6],[1,11,2],[1,6,3]]
    indList2 = Any[[1,2,3,4],[10,7,-3,6],[-1,11,10],[3,4,-2,8],[1,2,11,9],[5,8,6],[5,9,7]]
    indList3 = Any[[5,7,3,1],[10,9,-3,8],[-1,11,10],[4,3,-2,2],[4,5,11,6],[1,2,8],[7,6,9]]
    indList4 = Any[[3,7,2,-1],[5,6,4,-3],[2,1,4],[3,1,5],[7,-2,6]]
    wEnv = @ncon(Any[hamAB,rhoBA,conj(w),u,conj(u),v,conj(v)],indList1) +
   			@ncon(Any[hamBA,rhoBA,conj(w),u,conj(u),v,conj(v)],indList2) +
   			@ncon(Any[hamAB,rhoBA,conj(w),u,conj(u),v,conj(v)],indList3) +
   			@ncon(Any[hamBA,rhoAB,v,conj(v),conj(w)],indList4);
    return wEnv
end

@tensor function IsoEnvW3(hamAB,hamBA,rhoBA,rhoAB,w,v,u)
    wEnv[-1,-2,-3] :=
    	hamAB[7,8,-1,9]*rhoBA[4,3,-3,2]*conj(w[7,5,4])*u[9,10,-2,11]*conj(u[8,10,5,6])*v[1,11,2]*conj(v[1,6,3]) +
    	hamBA[1,2,3,4]*rhoBA[10,7,-3,6]*conj(w[-1,11,10])*u[3,4,-2,8]*conj(u[1,2,11,9])*v[5,8,6]*conj(v[5,9,7]) +
    	hamAB[5,7,3,1]*rhoBA[10,9,-3,8]*conj(w[-1,11,10])*u[4,3,-2,2]*conj(u[4,5,11,6])*v[1,2,8]*conj(v[7,6,9]) +
    	hamBA[3,7,2,-1]*rhoAB[5,6,4,-3]*v[2,1,4]*conj(v[3,1,5])*conj(w[7,-2,6])
    return wEnv
    end
end</code></pre><p>All indices appearing in this problem are of size <code>χ</code>. For tensors with <code>ComplexF64</code> eltype and values of <code>χ</code> in <code>2:2:32</code>, the reported minimal times using the <code>@belapsed</code> macro from <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a> are given by</p><table><tr><th style="text-align: right">χ</th><th style="text-align: right">IsoEnvW1: ncon</th><th style="text-align: right">IsoEnvW2: @ncon</th><th style="text-align: right">IsoEnvW3: @tensor</th></tr><tr><td style="text-align: right">2</td><td style="text-align: right">0.000154413</td><td style="text-align: right">0.000348091</td><td style="text-align: right">6.4897e-5</td></tr><tr><td style="text-align: right">4</td><td style="text-align: right">0.000208224</td><td style="text-align: right">0.000400065</td><td style="text-align: right">9.5601e-5</td></tr><tr><td style="text-align: right">6</td><td style="text-align: right">0.000558442</td><td style="text-align: right">0.00076453</td><td style="text-align: right">0.000354621</td></tr><tr><td style="text-align: right">8</td><td style="text-align: right">0.00138887</td><td style="text-align: right">0.00150175</td><td style="text-align: right">0.000982109</td></tr><tr><td style="text-align: right">10</td><td style="text-align: right">0.00506386</td><td style="text-align: right">0.00365188</td><td style="text-align: right">0.00288137</td></tr><tr><td style="text-align: right">12</td><td style="text-align: right">0.0126571</td><td style="text-align: right">0.00959403</td><td style="text-align: right">0.00818371</td></tr><tr><td style="text-align: right">14</td><td style="text-align: right">0.0292822</td><td style="text-align: right">0.0216231</td><td style="text-align: right">0.0184712</td></tr><tr><td style="text-align: right">16</td><td style="text-align: right">0.0531353</td><td style="text-align: right">0.0410914</td><td style="text-align: right">0.0359749</td></tr><tr><td style="text-align: right">18</td><td style="text-align: right">0.225333</td><td style="text-align: right">0.0774705</td><td style="text-align: right">0.0688475</td></tr><tr><td style="text-align: right">20</td><td style="text-align: right">0.43358</td><td style="text-align: right">0.139873</td><td style="text-align: right">0.129315</td></tr><tr><td style="text-align: right">22</td><td style="text-align: right">0.601685</td><td style="text-align: right">0.243468</td><td style="text-align: right">0.221995</td></tr><tr><td style="text-align: right">24</td><td style="text-align: right">0.902662</td><td style="text-align: right">0.459746</td><td style="text-align: right">0.427615</td></tr><tr><td style="text-align: right">26</td><td style="text-align: right">1.2379</td><td style="text-align: right">0.66722</td><td style="text-align: right">0.622856</td></tr><tr><td style="text-align: right">28</td><td style="text-align: right">1.84234</td><td style="text-align: right">1.08766</td><td style="text-align: right">1.0322</td></tr><tr><td style="text-align: right">30</td><td style="text-align: right">2.58548</td><td style="text-align: right">1.53826</td><td style="text-align: right">1.44854</td></tr><tr><td style="text-align: right">32</td><td style="text-align: right">3.85758</td><td style="text-align: right">2.44087</td><td style="text-align: right">2.34229</td></tr></table><p>Throughout this range of <code>χ</code> values, method 3 that uses the <code>@tensor</code> macro is consistenly the fastest, both at small <code>χ</code>, where the type stability and the fact that the contraction pattern is analyzed at compile time matters, and at large <code>χ</code>, where the caching of temporaries matters. The direct <code>ncon</code> call has neither of those two features (unless the fourth positional argument is specified, which was not the case here). The <code>@ncon</code> solution provides a hook into the cache and thus is competitive with <code>@tensor</code> for large <code>χ</code>, where the cost is dominated by matrix multiplication and allocations. For small <code>χ</code>, <code>@ncon</code> is also plagued by the runtime analysis of the contraction, but is even worse then <code>ncon</code>. For small <code>χ</code>, the unavoidable type instabilities in <code>ncon</code> implementation seem to make the interaction with the cache hurtful rather than advantageous.</p><h2 id="Multithreading-and-GPU-evaluation-of-tensor-contractions-with-@cutensor"><a class="docs-heading-anchor" href="#Multithreading-and-GPU-evaluation-of-tensor-contractions-with-@cutensor">Multithreading and GPU evaluation of tensor contractions with <code>@cutensor</code></a><a id="Multithreading-and-GPU-evaluation-of-tensor-contractions-with-@cutensor-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreading-and-GPU-evaluation-of-tensor-contractions-with-@cutensor" title="Permalink"></a></h2><p>Every index expression will be evaluated as a sequence of elementary tensor operations, i.e. permuted additions, partial traces and contractions, which are implemented for strided arrays as discussed in <a href="../#Package-features">Package features</a>. In particular, these implementations rely on <a href="https://github.com/Jutho/Strided.jl">Strided.jl</a>, and we refer to this package for a full specification of which arrays are supported. As a rule of thumb, <code>Array</code>s from Julia base, as well as <code>view</code>s thereof if sliced with a combination of <code>Integer</code>s and <code>Range</code>s. Special types such as <code>Adjoint</code> and <code>Transpose</code> from Base are also supported. For permuted addition and partial traces, native Julia implementations are used which could benefit from multithreading if <code>JULIA_NUM_THREADS&gt;1</code>. The binary contraction is performed by first permuting the two input tensors into a form such that the contraction becomes equivalent to one matrix multiplication on the whole data, followed by a final permutation to bring the indices of the output tensor into the desired order. This approach allows to use the highly efficient matrix multiplication (<code>gemm</code>) from BLAS, which is multithreaded by default. There is also a native contraction implementation that is used for e.g. arrays with an <code>eltype</code> that is not <code>&lt;:LinearAlgebra.BlasFloat</code>. It performs the contraction directly without the additional permutations, but still in a cache-friendly and multithreaded way (again relying on <code>JULIA_NUM_THREADS&gt;1</code>). This implementation can sometimes be faster even for <code>BlasFloat</code> types, and the use of BLAS can be disabled globally by calling <code>disable_blas()</code>. It is currently not possible to control the use of BLAS at the level of individual contractions.</p><p>Since TensorOperations v2.0, the necessary implementations are also available for <code>CuArray</code> objects of the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> library. This implementation is essentially a simple wrapper over the CUTENSOR library of NVidia, and as such has certain restrictions as a result thereof. Native Julia alternatives using CUDA.jl or KernelAbstractions.jl might be provided in the future.</p><p>Mixed operations between host arrays (e.g. <code>Array</code>) and device arrays (e.g. <code>CuArray</code>) will fail. However, if one wants to harness the computing power of the GPU to perform all tensor operations, there is a dedicated macro <code>@cutensor</code>. This will transfer all arrays to the GPU before performing the requested operations. If the output is an existing host array, the result will be copied back. If a new result array is created (i.e. using <code>:=</code>), it will remain on the GPU device and it is up to the user to transfer it back. Arrays are transfered to the GPU just before they are first used, and in a complicated tensor expression, this might have the benefit that transer of the later arrays overlaps with computation of earlier operations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« TensorOperations.jl</a><a class="docs-footer-nextpage" href="../functions/">Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 5 October 2021 11:39">Tuesday 5 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
